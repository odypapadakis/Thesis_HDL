hal(64): 15.20-s038: (c) Copyright 1995-2017 Cadence Design Systems, Inc.
hal: Options:   -cdslib /localdisk/users/papadako/diplomatiki/A_HDL/Arbitration_submodule/1_SIMVISION/cds.lib -logfile hal.log worklib.ArbitrationSubModule_Testbench:module.
hal: Snapshot:  worklib.ArbitrationSubModule_Testbench:module.
hal: Workspace: /users/papadako/Desktop/Link to diplomatiki/A_HDL/Arbitration_submodule/1_SIMVISION.
hal: Date: Wed Nov 17 01:07:53 EET 2021.

hal: Running on elaborated SNAPSHOT.....

  ==========================================================================
Performing lint checks 

halcheck(64): 15.20-s038: (c) Copyright 1995-2017 Cadence Design Systems, Inc.
visadev(64): 15.20-s038: (c) Copyright 1995-2017 Cadence Design Systems, Inc.
`timescale 1ns / 1ns   // <time_unit> / <time_precision>
|
halcheck: *N,CDNOTE (./ArbitrationSubModule_Testbench.v,1|0): The compiler directive '`timescale' is used in the RTL.
*the Processor 		--> Pseudo_CPU 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,6|0): HDL source line contains one or more control characters.
*the Bus  			--> Pseudo_BUS
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,7|0): HDL source line contains one or more control characters.
*the Bus Arbiter	--> Pseudo_Arbiter
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,8|0): HDL source line contains one or more control characters.
* The purpose of this TestBench to determine wether the rbitration module can successfully
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,10|0): The HDL source line is 90 characters, which exceeds the recommended length of 80 characters.
	// Data bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,27|0): HDL source line contains one or more control characters.
		// Processor --> Arbitration Module
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,29|0): HDL source line contains one or more control characters.
		reg 		tb_P_DataMem_Read;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,30|0): HDL source line contains one or more control characters.
		reg	[3:0]   tb_P_DataMem_Write;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,31|0): HDL source line contains one or more control characters.
		reg	[29:0]	tb_P_DataMem_Address;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,32|0): HDL source line contains one or more control characters.
		reg	[31:0]	tb_P_DataMem_Out;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,33|0): HDL source line contains one or more control characters.
		// Arbitration Module --> Processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,35|0): HDL source line contains one or more control characters.
		wire	[31:0]	tb_P_DataMem_In;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,36|0): HDL source line contains one or more control characters.
		wire			tb_P_DataMem_Ready;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,37|0): HDL source line contains one or more control characters.
	//  Instruction Bus	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,40|0): HDL source line contains one or more control characters.
		// Processor --> Arbitration Module 	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,42|0): HDL source line contains one or more control characters.
		reg	[29:0]	tb_P_InstMem_Address;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,43|0): HDL source line contains one or more control characters.
		reg			tb_P_InstMem_Read;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,44|0): HDL source line contains one or more control characters.
		// Arbitration Module --> Processor		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,46|0): HDL source line contains one or more control characters.
		wire			tb_P_InstMem_Ready;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,47|0): HDL source line contains one or more control characters.
		wire	[31:0]	tb_P_InstMem_In;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,48|0): HDL source line contains one or more control characters.
	// Regarding the Data bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,55|0): HDL source line contains one or more control characters.
		//	Bus --> Arbitration Module
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,57|0): HDL source line contains one or more control characters.
		reg	[31:0]	tb_Bus_DataMem_In;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,58|0): HDL source line contains one or more control characters.
		reg			tb_Bus_DataMem_Ready;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,59|0): HDL source line contains one or more control characters.
		//	Arbitration Module --> Bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,61|0): HDL source line contains one or more control characters.
		wire			tb_Bus_DataMem_Read;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,62|0): HDL source line contains one or more control characters.
		wire	[3:0] 	tb_Bus_DataMem_Write;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,63|0): HDL source line contains one or more control characters.
		wire	[29:0]	tb_Bus_DataMem_Address;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,64|0): HDL source line contains one or more control characters.
		wire	[31:0]	tb_Bus_DataMem_Out;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,65|0): HDL source line contains one or more control characters.
	// Regarding the Instruction Bus 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,68|0): HDL source line contains one or more control characters.
		//	Bus --> Arbitration Module     
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,70|0): HDL source line contains one or more control characters.
		reg			tb_Bus_InstMem_Ready;   
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,71|0): HDL source line contains one or more control characters.
		reg	[31:0]	tb_Bus_InstMem_In;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,72|0): HDL source line contains one or more control characters.
		//	Arbitration Module -- > Bus		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,74|0): HDL source line contains one or more control characters.
		wire	[29:0]	tb_Bus_InstMem_Address;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,75|0): HDL source line contains one or more control characters.
		wire			tb_Bus_InstMem_Read;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,76|0): HDL source line contains one or more control characters.
	// Regarding the Data bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,81|0): HDL source line contains one or more control characters.
		wire	tb_D_Bus_RQ;		 	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,82|0): HDL source line contains one or more control characters.
		reg		tb_D_Bus_GRANT;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,83|0): HDL source line contains one or more control characters.
	// Regarding the Instruction Bus        
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,86|0): HDL source line contains one or more control characters.
		wire	tb_I_Bus_RQ;			 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,87|0): HDL source line contains one or more control characters.
		reg		tb_I_Bus_Arbiter_GRANT;  
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,88|0): HDL source line contains one or more control characters.
//uut signals 			// Testbench signals
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,97|0): HDL source line contains one or more control characters.
	.Bus_DataMem_In			(tb_Bus_DataMem_In),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,101|0): HDL source line contains one or more control characters.
	.Bus_DataMem_Ready		(tb_Bus_DataMem_Ready),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,102|0): HDL source line contains one or more control characters.
	.P_DataMem_Read			(tb_P_DataMem_Read),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,104|0): HDL source line contains one or more control characters.
	.P_DataMem_Write		(tb_P_DataMem_Write	),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,105|0): HDL source line contains one or more control characters.
	.P_DataMem_Address		(tb_P_DataMem_Address),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,106|0): HDL source line contains one or more control characters.
	.P_DataMem_Out			(tb_P_DataMem_Out),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,107|0): HDL source line contains one or more control characters.
	.P_DataMem_In			(tb_P_DataMem_In),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,109|0): HDL source line contains one or more control characters.
	.P_DataMem_Ready		(tb_P_DataMem_Ready),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,110|0): HDL source line contains one or more control characters.
	.Bus_DataMem_Read		(tb_Bus_DataMem_Read),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,112|0): HDL source line contains one or more control characters.
	.Bus_DataMem_Write		(tb_Bus_DataMem_Write),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,113|0): HDL source line contains one or more control characters.
	.Bus_DataMem_Address	(tb_Bus_DataMem_Address),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,114|0): HDL source line contains one or more control characters.
	.Bus_DataMem_Out		(tb_Bus_DataMem_Out),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,115|0): HDL source line contains one or more control characters.
	.D_Bus_RQ				(tb_D_Bus_RQ),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,117|0): HDL source line contains one or more control characters.
	.D_Bus_GRANT			(tb_D_Bus_GRANT),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,118|0): HDL source line contains one or more control characters.
	//Instruction Bus signal connections
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,120|0): HDL source line contains one or more control characters.
	.Bus_InstMem_Ready		(tb_Bus_InstMem_Ready),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,122|0): HDL source line contains one or more control characters.
	.Bus_InstMem_In			(tb_Bus_InstMem_In),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,123|0): HDL source line contains one or more control characters.
	.P_InstMem_Address		(tb_P_InstMem_Address),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,125|0): HDL source line contains one or more control characters.
	.P_InstMem_Read			(tb_P_InstMem_Read),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,126|0): HDL source line contains one or more control characters.
	.P_InstMem_Ready		(tb_P_InstMem_Ready),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,128|0): HDL source line contains one or more control characters.
	.P_InstMem_In			(tb_P_InstMem_In),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,129|0): HDL source line contains one or more control characters.
	.Bus_InstMem_Address	(tb_Bus_InstMem_Address),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,131|0): HDL source line contains one or more control characters.
	.Bus_InstMem_Read		(tb_Bus_InstMem_Read),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,132|0): HDL source line contains one or more control characters.
	.I_Bus_RQ				(tb_I_Bus_RQ),
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,134|0): HDL source line contains one or more control characters.
	.I_Bus_GRANT			(tb_I_Bus_Arbiter_GRANT)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,135|0): HDL source line contains one or more control characters.
// initial 		// Data initial block
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,141|0): HDL source line contains one or more control characters.
// 	begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,142|0): HDL source line contains one or more control characters.
// 		//Bus --> Arbitration Module
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,145|0): HDL source line contains one or more control characters.
// 		tb_Bus_DataMem_In		= 'd63;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,146|0): HDL source line contains one or more control characters.
// 		tb_Bus_DataMem_Ready	= 0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,147|0): HDL source line contains one or more control characters.
// 		// Processor --> Arbitration Module
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,149|0): HDL source line contains one or more control characters.
// 		tb_P_DataMem_Read		= 0;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,150|0): HDL source line contains one or more control characters.
// 		tb_P_DataMem_Write		= 0;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,151|0): HDL source line contains one or more control characters.
// 		tb_P_DataMem_Address	= 'd31;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,152|0): HDL source line contains one or more control characters.
// 		tb_P_DataMem_Out		= 'd127;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,153|0): HDL source line contains one or more control characters.
// 		tb_D_Bus_GRANT 			= 0;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,155|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Read		<= 1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,158|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,159|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Read		<= 0;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,160|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,161|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b0001;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,166|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,167|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b0;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,168|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b0000;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,169|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b0010;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,171|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b0000;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,172|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b0100;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,174|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,175|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b0;		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,176|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b0000;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,177|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b1000;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,179|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Write <= 4'b0000;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,180|0): HDL source line contains one or more control characters.
// 		#100 tb_P_DataMem_Read	<= 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,182|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,184|0): HDL source line contains one or more control characters.
// 		#50 tb_D_Bus_GRANT 	<= 1'b0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,185|0): HDL source line contains one or more control characters.
// 	end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,187|0): HDL source line contains one or more control characters.
//	It will function as follows:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,193|0): HDL source line contains one or more control characters.
//	FSM state: I_Arb_State_Idle
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,195|0): HDL source line contains one or more control characters.
//	It will initially set the bus as occupied, during which time we expect the arbitration submodule to 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,196|0): HDL source line contains one or more control characters.
//	It will initially set the bus as occupied, during which time we expect the arbitration submodule to 
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,196|0): The HDL source line is 103 characters, which exceeds the recommended length of 80 characters.
//	After th pseudo arbiter has received a request for bus usage  from the arbitraion submodule, 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,199|0): HDL source line contains one or more control characters.
//	After th pseudo arbiter has received a request for bus usage  from the arbitraion submodule, 
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,199|0): The HDL source line is 96 characters, which exceeds the recommended length of 80 characters.
// 	it should grant the bus to the submodule after a randomized amount of time, simulating the possibility
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,200|0): HDL source line contains one or more control characters.
// 	it should grant the bus to the submodule after a randomized amount of time, simulating the possibility
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,200|0): The HDL source line is 106 characters, which exceeds the recommended length of 80 characters.
//	thet the bus might be busy.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,201|0): HDL source line contains one or more control characters.
//	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,202|0): HDL source line contains one or more control characters.
localparam	Pseudo_I_Arbiter_State_Idle 			= 2'b00 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,206|0): HDL source line contains one or more control characters.
localparam	Pseudo_I_Arbiter_State_RQ_HIGH 			= 2'b01 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,207|0): HDL source line contains one or more control characters.
localparam	Pseudo_I_Arbiter_State_RQ_LOW 			= 2'b10 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,208|0): HDL source line contains one or more control characters.
localparam	Pseudo_I_Arbiter_State_Wait_MEM_LOW 	= 2'b11 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,209|0): HDL source line contains one or more control characters.
//	Pseudo Instruction Arbiter Sequential always Block
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,213|0): HDL source line contains one or more control characters.
	if(reset)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,216|0): HDL source line contains one or more control characters.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_State_Idle ; // On reset, go to the Idle state
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,217|0): HDL source line contains one or more control characters.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_State_Idle ; // On reset, go to the Idle state
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,217|0): The HDL source line is 99 characters, which exceeds the recommended length of 80 characters.
	else
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,218|0): HDL source line contains one or more control characters.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,219|0): HDL source line contains one or more control characters.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,219|0): The HDL source line is 114 characters, which exceeds the recommended length of 80 characters.
//	Pseudo Instruction Arbiter combinational always Block
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,224|0): HDL source line contains one or more control characters.
	case(Pseudo_I_Arbiter_Current_State)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,227|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,228|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	Pseudo_I_Arbiter_State_Idle: 	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,229|0): HDL source line contains one or more control characters.
		begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,230|0): HDL source line contains one or more control characters.
			tb_I_Bus_Arbiter_GRANT = 1'b0; // The bus is busy , therefore the arbiter drives the grant signal low.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,231|0): HDL source line contains one or more control characters.
			tb_I_Bus_Arbiter_GRANT = 1'b0; // The bus is busy , therefore the arbiter drives the grant signal low.
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,231|0): The HDL source line is 105 characters, which exceeds the recommended length of 80 characters.
			// If there is a request  and memory is ready
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,233|0): HDL source line contains one or more control characters.
			if( (tb_I_Bus_RQ == 1'b1)  && (tb_Bus_InstMem_Ready == 1'b0) )  
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,234|0): HDL source line contains one or more control characters.
				#50 Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_RQ_HIGH;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,235|0): HDL source line contains one or more control characters.
			else
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,236|0): HDL source line contains one or more control characters.
				Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_Idle;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,237|0): HDL source line contains one or more control characters.
		end	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,239|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,240|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	Pseudo_I_Arbiter_State_RQ_HIGH:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,241|0): HDL source line contains one or more control characters.
		begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,242|0): HDL source line contains one or more control characters.
			#50  tb_I_Bus_Arbiter_GRANT = 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,243|0): HDL source line contains one or more control characters.
			if(tb_I_Bus_RQ == 1'b0)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,245|0): HDL source line contains one or more control characters.
				begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,246|0): HDL source line contains one or more control characters.
					#50 Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_RQ_LOW  ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,247|0): HDL source line contains one or more control characters.
				end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,248|0): HDL source line contains one or more control characters.
			else
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,249|0): HDL source line contains one or more control characters.
				Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_RQ_HIGH;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,250|0): HDL source line contains one or more control characters.
			end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,251|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,252|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	Pseudo_I_Arbiter_State_RQ_LOW:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,253|0): HDL source line contains one or more control characters.
		begin	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,254|0): HDL source line contains one or more control characters.
			#50  tb_I_Bus_Arbiter_GRANT = 1'b0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,255|0): HDL source line contains one or more control characters.
			#50  Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_Idle  ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,256|0): HDL source line contains one or more control characters.
					
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,257|0): HDL source line contains one or more control characters.
		end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,258|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,259|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	// Pseudo_I_Arb_State_Wait_MEM_LOW:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,260|0): HDL source line contains one or more control characters.
	// 	begin	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,261|0): HDL source line contains one or more control characters.
	// 		if(tb_Bus_InstMem_Ready == 1'b0)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,262|0): HDL source line contains one or more control characters.
	// 			begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,263|0): HDL source line contains one or more control characters.
	// 				#50 I_Arb_State = I_Arb_State_Idle  ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,264|0): HDL source line contains one or more control characters.
	// 			end		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,265|0): HDL source line contains one or more control characters.
	// 	end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,266|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,267|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	default:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,268|0): HDL source line contains one or more control characters.
		begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,269|0): HDL source line contains one or more control characters.
			Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_Idle ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,270|0): HDL source line contains one or more control characters.
			tb_I_Bus_Arbiter_GRANT = 1'b0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,271|0): HDL source line contains one or more control characters.
		end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,272|0): HDL source line contains one or more control characters.
	endcase	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,274|0): HDL source line contains one or more control characters.
localparam	Pseudo_I_Memory_State_Idle 			= 2'b00 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,282|0): HDL source line contains one or more control characters.
localparam	Pseudo_I_Memory_State_Read_HIGH 		= 2'b01 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,283|0): HDL source line contains one or more control characters.
//localparam	Pseudo_I_Memory_State_Wait_MEM_LOW 	= 2'b11 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,284|0): HDL source line contains one or more control characters.
//	Pseudo Instruction Memory Sequential always Block
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,288|0): HDL source line contains one or more control characters.
	if(reset)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,291|0): HDL source line contains one or more control characters.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_State_Idle ; // On reset, go to the Idle state
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,292|0): HDL source line contains one or more control characters.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_State_Idle ; // On reset, go to the Idle state
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,292|0): The HDL source line is 97 characters, which exceeds the recommended length of 80 characters.
	else
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,293|0): HDL source line contains one or more control characters.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_Next_State ; // If not resetting, start sequencing the states
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,294|0): HDL source line contains one or more control characters.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_Next_State ; // If not resetting, start sequencing the states
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,294|0): The HDL source line is 112 characters, which exceeds the recommended length of 80 characters.
//	Pseudo Instruction Memory combinational always Block
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,299|0): HDL source line contains one or more control characters.
	case(Pseudo_I_Memory_Current_State)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,302|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,303|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	Pseudo_I_Memory_State_Idle: 	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,304|0): HDL source line contains one or more control characters.
		begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,305|0): HDL source line contains one or more control characters.
			// When Idle Drive the Instruction Bus with 001 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,306|0): HDL source line contains one or more control characters.
			#50 tb_Bus_InstMem_In = 32'd1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,307|0): HDL source line contains one or more control characters.
			// And show that the data is not valid 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,309|0): HDL source line contains one or more control characters.
			#25 tb_Bus_InstMem_Ready = 0'b0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,310|0): HDL source line contains one or more control characters.
			#25 tb_Bus_InstMem_Ready = 0'b0;
|
halcheck: *W,BITUNS (./ArbitrationSubModule_Testbench.v,310|0): Not all bits of constant '0'b0' are explicitly specified.
halcheck: (./ArbitrationSubModule_Testbench.v,310): Constant extended by 31 bits to -> 0'b(0000000000000000000000000000000)0.
			// When the read signal goes high
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,313|0): HDL source line contains one or more control characters.
			if( (tb_Bus_InstMem_Read == 1'b1) )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,314|0): HDL source line contains one or more control characters.
				#50 Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Read_HIGH;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,315|0): HDL source line contains one or more control characters.
			else
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,316|0): HDL source line contains one or more control characters.
				Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Idle;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,317|0): HDL source line contains one or more control characters.
		end	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,319|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,320|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	Pseudo_I_Memory_State_Read_HIGH:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,321|0): HDL source line contains one or more control characters.
		begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,322|0): HDL source line contains one or more control characters.
			// Add 4 to the Address and return it as data
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,323|0): HDL source line contains one or more control characters.
			#50 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 32'd4;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,324|0): HDL source line contains one or more control characters.
			// Raise the ready signal, to inform that the data being served is valid
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,326|0): HDL source line contains one or more control characters.
			#50 tb_Bus_InstMem_Ready = 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,327|0): HDL source line contains one or more control characters.
			// When the read signal goes low move on to Idle
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,329|0): HDL source line contains one or more control characters.
			if(tb_Bus_InstMem_Read == 1'b0)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,330|0): HDL source line contains one or more control characters.
				begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,331|0): HDL source line contains one or more control characters.
					#50 Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Idle  ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,332|0): HDL source line contains one or more control characters.
				end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,333|0): HDL source line contains one or more control characters.
			else
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,334|0): HDL source line contains one or more control characters.
				Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Read_HIGH;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,335|0): HDL source line contains one or more control characters.
			end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,336|0): HDL source line contains one or more control characters.
//------------------------------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,337|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
	default:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,338|0): HDL source line contains one or more control characters.
		begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,339|0): HDL source line contains one or more control characters.
			Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Idle ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,340|0): HDL source line contains one or more control characters.
		end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,341|0): HDL source line contains one or more control characters.
	endcase	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,343|0): HDL source line contains one or more control characters.
localparam	Mem_State_Idle 			    = 0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,358|0): HDL source line contains one or more control characters.
localparam	Mem_State_Request_placed 	= 1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,359|0): HDL source line contains one or more control characters.
localparam	Mem_State_Data_ready 		= 2;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,360|0): HDL source line contains one or more control characters.
localparam	Mem_State_Data_read 		= 3;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,361|0): HDL source line contains one or more control characters.
	if (reset)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,367|0): HDL source line contains one or more control characters.
		begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,368|0): HDL source line contains one or more control characters.
			tb_Bus_InstMem_Ready 	= 1'b0;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,369|0): HDL source line contains one or more control characters.
			tb_Bus_InstMem_In 		= 'h0000;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,370|0): HDL source line contains one or more control characters.
			Mem_State = Mem_State_Idle;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,371|0): HDL source line contains one or more control characters.
		end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,372|0): HDL source line contains one or more control characters.
	else
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,373|0): HDL source line contains one or more control characters.
	begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,374|0): HDL source line contains one or more control characters.
		case(Mem_State)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,375|0): HDL source line contains one or more control characters.
						
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,376|0): HDL source line contains one or more control characters.
					Mem_State_Idle:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,377|0): HDL source line contains one or more control characters.
					begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,378|0): HDL source line contains one or more control characters.
						tb_Bus_InstMem_Ready 	= 1'b0;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,379|0): HDL source line contains one or more control characters.
						tb_Bus_InstMem_In 		= 'hFFFF;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,380|0): HDL source line contains one or more control characters.
						if(tb_Bus_InstMem_Read == 1'b1)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,381|0): HDL source line contains one or more control characters.
							Mem_State = Mem_State_Request_placed;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,382|0): HDL source line contains one or more control characters.
					end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,384|0): HDL source line contains one or more control characters.
					Mem_State_Request_placed:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,386|0): HDL source line contains one or more control characters.
					begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,387|0): HDL source line contains one or more control characters.
						#100 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 1 ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,389|0): HDL source line contains one or more control characters.
						#100 tb_Bus_InstMem_Ready 	= 1'b1;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,390|0): HDL source line contains one or more control characters.
						Mem_State = Mem_State_Data_ready ;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,391|0): HDL source line contains one or more control characters.
					end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,392|0): HDL source line contains one or more control characters.
					Mem_State_Data_ready:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,394|0): HDL source line contains one or more control characters.
					begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,395|0): HDL source line contains one or more control characters.
						#50 if(tb_Bus_InstMem_Read == 1'b0)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,396|0): HDL source line contains one or more control characters.
							Mem_State = Mem_State_Data_read;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,397|0): HDL source line contains one or more control characters.
					end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,399|0): HDL source line contains one or more control characters.
					Mem_State_Data_read:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,401|0): HDL source line contains one or more control characters.
					begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,402|0): HDL source line contains one or more control characters.
						tb_Bus_InstMem_Ready 	= 1'b0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,403|0): HDL source line contains one or more control characters.
						Mem_State =	Mem_State_Idle;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,404|0): HDL source line contains one or more control characters.
					end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,405|0): HDL source line contains one or more control characters.
		endcase
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,407|0): HDL source line contains one or more control characters.
	end	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,409|0): HDL source line contains one or more control characters.
initial		// Instruction initial block
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,418|0): HDL source line contains one or more control characters.
	begin
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,419|0): HDL source line contains one or more control characters.
		$display("-----------------------------------------		Instruction initial block	-------------------------------");
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,420|0): HDL source line contains one or more control characters.
		$display("-----------------------------------------		Instruction initial block	-------------------------------");
|
halcheck: *W,MAXLEN (./ArbitrationSubModule_Testbench.v,420|0): The HDL source line is 115 characters, which exceeds the recommended length of 80 characters.
		heartbeat = 0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,422|0): HDL source line contains one or more control characters.
		clk = 0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,423|0): HDL source line contains one or more control characters.
		reset = 1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,424|0): HDL source line contains one or more control characters.
		// Processor is Idle and does not wan to read anything.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,427|0): HDL source line contains one or more control characters.
		tb_P_InstMem_Address	= 'h1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,428|0): HDL source line contains one or more control characters.
		tb_P_InstMem_Address	= 'h1;
|
halcheck: *W,BITUNS (./ArbitrationSubModule_Testbench.v,428|0): Not all bits of constant ''h1' are explicitly specified.
halcheck: (./ArbitrationSubModule_Testbench.v,428): Constant extended by 28 bits to -> 'b(0000000000000000000000000000)0001.
		tb_P_InstMem_Read		= 1'b0; 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,429|0): HDL source line contains one or more control characters.
		// System is running
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,431|0): HDL source line contains one or more control characters.
		#100 reset = 0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,432|0): HDL source line contains one or more control characters.
		// Processor wants the Instruction at address 5
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,436|0): HDL source line contains one or more control characters.
		#200 tb_P_InstMem_Address	= 32'd5;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,437|0): HDL source line contains one or more control characters.
		#50 tb_P_InstMem_Read = 1'b1;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,438|0): HDL source line contains one or more control characters.
		// Processor no longer need the instruction
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,440|0): HDL source line contains one or more control characters.
		#500 tb_P_InstMem_Read = 1'b0;
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,441|0): HDL source line contains one or more control characters.
	end
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,448|0): HDL source line contains one or more control characters.
	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,453|0): HDL source line contains one or more control characters.
always #100 heartbeat = !heartbeat;	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule_Testbench.v,454|0): HDL source line contains one or more control characters.
module ArbitrationSubModule_Testbench;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,16|0): Module name 'ArbitrationSubModule_Testbench' uses uppercase characters.
module ArbitrationSubModule_Testbench;
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,16|0): Identifier name 'ArbitrationSubModule_Testbench' is not of appropriate length (4 to 16 characters).
module ArbitrationSubModule_Testbench;
|
halcheck: *W,NEEDIO (./ArbitrationSubModule_Testbench.v,16|0): Top-level module 'ArbitrationSubModule_Testbench' has no inputs/outputs/inouts.
		wire	[31:0]	tb_P_DataMem_In;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,36|0): Net name 'tb_P_DataMem_In' uses uppercase characters.
		wire	[31:0]	tb_P_DataMem_In;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,36|0): Numeric value '31' used for identifier 'tb_P_DataMem_In'. Use constants to avoid portability issues.
		wire			tb_P_DataMem_Ready;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,37|0): Net name 'tb_P_DataMem_Ready' uses uppercase characters.
		wire			tb_P_InstMem_Ready;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,47|0): Net name 'tb_P_InstMem_Ready' uses uppercase characters.
		wire	[31:0]	tb_P_InstMem_In;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,48|0): Net name 'tb_P_InstMem_In' uses uppercase characters.
		wire	[31:0]	tb_P_InstMem_In;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,48|0): Numeric value '31' used for identifier 'tb_P_InstMem_In'. Use constants to avoid portability issues.
		wire			tb_Bus_DataMem_Read;		
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,62|0): Net name 'tb_Bus_DataMem_Read' uses uppercase characters.
		wire	[3:0] 	tb_Bus_DataMem_Write;		
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,63|0): Net name 'tb_Bus_DataMem_Write' uses uppercase characters.
		wire	[3:0] 	tb_Bus_DataMem_Write;		
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,63|0): Numeric value '3' used for identifier 'tb_Bus_DataMem_Write'. Use constants to avoid portability issues.
		wire	[29:0]	tb_Bus_DataMem_Address;	
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,64|0): Net name 'tb_Bus_DataMem_Address' uses uppercase characters.
		wire	[29:0]	tb_Bus_DataMem_Address;	
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,64|0): Numeric value '29' used for identifier 'tb_Bus_DataMem_Address'. Use constants to avoid portability issues.
		wire	[31:0]	tb_Bus_DataMem_Out;		
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,65|0): Net name 'tb_Bus_DataMem_Out' uses uppercase characters.
		wire	[31:0]	tb_Bus_DataMem_Out;		
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,65|0): Numeric value '31' used for identifier 'tb_Bus_DataMem_Out'. Use constants to avoid portability issues.
		wire	[29:0]	tb_Bus_InstMem_Address;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,75|0): Net name 'tb_Bus_InstMem_Address' uses uppercase characters.
		wire	[29:0]	tb_Bus_InstMem_Address;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,75|0): Numeric value '29' used for identifier 'tb_Bus_InstMem_Address'. Use constants to avoid portability issues.
		wire			tb_Bus_InstMem_Read;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,76|0): Net name 'tb_Bus_InstMem_Read' uses uppercase characters.
		wire	tb_D_Bus_RQ;		 	
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,82|0): Net name 'tb_D_Bus_RQ' uses uppercase characters.
		wire	tb_I_Bus_RQ;			 
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,87|0): Net name 'tb_I_Bus_RQ' uses uppercase characters.
		reg 		tb_P_DataMem_Read;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,30|0): Register name 'tb_P_DataMem_Read' uses uppercase characters.
		reg	[3:0]   tb_P_DataMem_Write;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,31|0): Register name 'tb_P_DataMem_Write' uses uppercase characters.
		reg	[3:0]   tb_P_DataMem_Write;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,31|0): Numeric value '3' used for identifier 'tb_P_DataMem_Write'. Use constants to avoid portability issues.
		reg	[29:0]	tb_P_DataMem_Address;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,32|0): Register name 'tb_P_DataMem_Address' uses uppercase characters.
		reg	[29:0]	tb_P_DataMem_Address;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,32|0): Numeric value '29' used for identifier 'tb_P_DataMem_Address'. Use constants to avoid portability issues.
		reg	[31:0]	tb_P_DataMem_Out;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,33|0): Register name 'tb_P_DataMem_Out' uses uppercase characters.
		reg	[31:0]	tb_P_DataMem_Out;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,33|0): Numeric value '31' used for identifier 'tb_P_DataMem_Out'. Use constants to avoid portability issues.
		reg	[29:0]	tb_P_InstMem_Address;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,43|0): Register name 'tb_P_InstMem_Address' uses uppercase characters.
		reg	[29:0]	tb_P_InstMem_Address;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,43|0): Numeric value '29' used for identifier 'tb_P_InstMem_Address'. Use constants to avoid portability issues.
		reg			tb_P_InstMem_Read;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,44|0): Register name 'tb_P_InstMem_Read' uses uppercase characters.
		reg	[31:0]	tb_Bus_DataMem_In;		
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,58|0): Register name 'tb_Bus_DataMem_In' uses uppercase characters.
		reg	[31:0]	tb_Bus_DataMem_In;		
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,58|0): Numeric value '31' used for identifier 'tb_Bus_DataMem_In'. Use constants to avoid portability issues.
		reg			tb_Bus_DataMem_Ready;	
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,59|0): Register name 'tb_Bus_DataMem_Ready' uses uppercase characters.
		reg			tb_Bus_InstMem_Ready;   
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,71|0): Register name 'tb_Bus_InstMem_Ready' uses uppercase characters.
		reg	[31:0]	tb_Bus_InstMem_In;		
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,72|0): Register name 'tb_Bus_InstMem_In' uses uppercase characters.
		reg	[31:0]	tb_Bus_InstMem_In;		
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,72|0): Numeric value '31' used for identifier 'tb_Bus_InstMem_In'. Use constants to avoid portability issues.
		reg		tb_D_Bus_GRANT;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,83|0): Register name 'tb_D_Bus_GRANT' uses uppercase characters.
		reg		tb_I_Bus_Arbiter_GRANT;  
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,88|0): Register name 'tb_I_Bus_Arbiter_GRANT' uses uppercase characters.
reg [1:0] Pseudo_I_Arbiter_Current_State,Pseudo_I_Arbiter_Next_State ;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,204|0): Register name 'Pseudo_I_Arbiter_Current_State' uses uppercase characters.
reg [1:0] Pseudo_I_Arbiter_Current_State,Pseudo_I_Arbiter_Next_State ;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,204|0): Numeric value '1' used for identifier 'Pseudo_I_Arbiter_Current_State'. Use constants to avoid portability issues.
reg [1:0] Pseudo_I_Arbiter_Current_State,Pseudo_I_Arbiter_Next_State ;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,204|0): Register name 'Pseudo_I_Arbiter_Next_State' uses uppercase characters.
reg [1:0] Pseudo_I_Memory_Current_State,Pseudo_I_Memory_Next_State ;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,280|0): Register name 'Pseudo_I_Memory_Current_State' uses uppercase characters.
reg [1:0] Pseudo_I_Memory_Current_State,Pseudo_I_Memory_Next_State ;
|
halcheck: *W,STYVAL (./ArbitrationSubModule_Testbench.v,280|0): Numeric value '1' used for identifier 'Pseudo_I_Memory_Current_State'. Use constants to avoid portability issues.
reg [1:0] Pseudo_I_Memory_Current_State,Pseudo_I_Memory_Next_State ;
|
halcheck: *W,LCVARN (./ArbitrationSubModule_Testbench.v,280|0): Register name 'Pseudo_I_Memory_Next_State' uses uppercase characters.
localparam	Pseudo_I_Arbiter_State_Idle 			= 2'b00 ;
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,206|0): Identifier name 'Pseudo_I_Arbiter_State_Idle' is not of appropriate length (4 to 16 characters).
localparam	Pseudo_I_Arbiter_State_Idle 			= 2'b00 ;
|
halcheck: *W,UCCONN (./ArbitrationSubModule_Testbench.v,206|0): Lowercase characters used for identifier 'Pseudo_I_Arbiter_State_Idle'. Use uppercase characters for names of constants and user-defined types.
localparam	Pseudo_I_Arbiter_State_RQ_HIGH 			= 2'b01 ;
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,207|0): Identifier name 'Pseudo_I_Arbiter_State_RQ_HIGH' is not of appropriate length (4 to 16 characters).
localparam	Pseudo_I_Arbiter_State_RQ_HIGH 			= 2'b01 ;
|
halcheck: *W,UCCONN (./ArbitrationSubModule_Testbench.v,207|0): Lowercase characters used for identifier 'Pseudo_I_Arbiter_State_RQ_HIGH'. Use uppercase characters for names of constants and user-defined types.
localparam	Pseudo_I_Arbiter_State_RQ_LOW 			= 2'b10 ;
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,208|0): Identifier name 'Pseudo_I_Arbiter_State_RQ_LOW' is not of appropriate length (4 to 16 characters).
localparam	Pseudo_I_Arbiter_State_RQ_LOW 			= 2'b10 ;
|
halcheck: *W,UCCONN (./ArbitrationSubModule_Testbench.v,208|0): Lowercase characters used for identifier 'Pseudo_I_Arbiter_State_RQ_LOW'. Use uppercase characters for names of constants and user-defined types.
localparam	Pseudo_I_Arbiter_State_Wait_MEM_LOW 	= 2'b11 ;
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,209|0): Identifier name 'Pseudo_I_Arbiter_State_Wait_MEM_LOW' is not of appropriate length (4 to 16 characters).
localparam	Pseudo_I_Arbiter_State_Wait_MEM_LOW 	= 2'b11 ;
|
halcheck: *W,UCCONN (./ArbitrationSubModule_Testbench.v,209|0): Lowercase characters used for identifier 'Pseudo_I_Arbiter_State_Wait_MEM_LOW'. Use uppercase characters for names of constants and user-defined types.
localparam	Pseudo_I_Memory_State_Idle 			= 2'b00 ;
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,282|0): Identifier name 'Pseudo_I_Memory_State_Idle' is not of appropriate length (4 to 16 characters).
localparam	Pseudo_I_Memory_State_Idle 			= 2'b00 ;
|
halcheck: *W,UCCONN (./ArbitrationSubModule_Testbench.v,282|0): Lowercase characters used for identifier 'Pseudo_I_Memory_State_Idle'. Use uppercase characters for names of constants and user-defined types.
localparam	Pseudo_I_Memory_State_Read_HIGH 		= 2'b01 ;
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,283|0): Identifier name 'Pseudo_I_Memory_State_Read_HIGH' is not of appropriate length (4 to 16 characters).
localparam	Pseudo_I_Memory_State_Read_HIGH 		= 2'b01 ;
|
halcheck: *W,UCCONN (./ArbitrationSubModule_Testbench.v,283|0): Lowercase characters used for identifier 'Pseudo_I_Memory_State_Read_HIGH'. Use uppercase characters for names of constants and user-defined types.
always@(posedge clk or posedge reset) 
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,215|0): Missing begin/end statement in the 'always' block.
	if(reset)
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,216|0): Missing begin/end statement in the 'if' block.
begin
|
halcheck: *W,NOBLKN (./ArbitrationSubModule_Testbench.v,226|0): Each block should be labeled with a meaningful name.
			if( (tb_I_Bus_RQ == 1'b1)  && (tb_Bus_InstMem_Ready == 1'b0) )  
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,234|0): Missing begin/end statement in the 'if' block.
			if( (tb_I_Bus_RQ == 1'b1)  && (tb_Bus_InstMem_Ready == 1'b0) )  
|
halcheck: *W,REVROP (./ArbitrationSubModule_Testbench.v,234|0): Register 'tb_Bus_InstMem_Ready' is being read/assigned outside the process in which it was assigned using a blocking assignment.
halcheck: (./ArbitrationSubModule_Testbench.v,300): Assigned using blocking assignment in this process.
			else
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,249|0): Missing begin/end statement in the 'else' block.
always@(posedge clk or posedge reset) 
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,290|0): Missing begin/end statement in the 'always' block.
	if(reset)
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,291|0): Missing begin/end statement in the 'if' block.
begin
|
halcheck: *W,NOBLKN (./ArbitrationSubModule_Testbench.v,301|0): Each block should be labeled with a meaningful name.
			#25 tb_Bus_InstMem_Ready = 0'b0;
|
halcheck: *W,TRUNCZ (./ArbitrationSubModule_Testbench.v,310|0): Truncation in constant conversion without a loss of bits in module/design-unit ArbitrationSubModule_Testbench.
			if( (tb_Bus_InstMem_Read == 1'b1) )
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,314|0): Missing begin/end statement in the 'if' block.
			#50 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 32'd4;
|
halcheck: *W,LRGOPR (./ArbitrationSubModule_Testbench.v,324|0): Arithmetic or relational operation performed on large operands in module/design-unit ArbitrationSubModule_Testbench.
			#50 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 32'd4;
|
halcheck: *W,UELOPR (./ArbitrationSubModule_Testbench.v,324|0): Unequal length operand in bit/arithmetic operator PLUS in module/design-unit ArbitrationSubModule_Testbench.
halcheck: (./ArbitrationSubModule_Testbench.v,324): LHS operand 'tb_Bus_InstMem_Addre...' is 30 bits, RHS operand '32'd4' is 32 bits.
			else
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,334|0): Missing begin/end statement in the 'else' block.
	begin
|
halcheck: *W,NOBLKN (./ArbitrationSubModule_Testbench.v,419|0): Each block should be labeled with a meaningful name.
		$display("-----------------------------------------		Instruction initial block	-------------------------------");
|
halcheck: *W,BADSYS (./ArbitrationSubModule_Testbench.v,420|0): System task $display in module 'ArbitrationSubModule_Testbench' is ignored.
		heartbeat = 0;
|
halcheck: *W,IMPDTC (./ArbitrationSubModule_Testbench.v,422|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit ArbitrationSubModule_Testbench.
		heartbeat = 0;
|
halcheck: *W,INTTOB (./ArbitrationSubModule_Testbench.v,422|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit ArbitrationSubModule_Testbench.
		heartbeat = 0;
|
halcheck: *W,TRUNCZ (./ArbitrationSubModule_Testbench.v,422|0): Truncation in constant conversion without a loss of bits in module/design-unit ArbitrationSubModule_Testbench.
		heartbeat = 0;
|
halcheck: *W,REVROP (./ArbitrationSubModule_Testbench.v,422|0): Register 'heartbeat' is being read/assigned outside the process in which it was assigned using a blocking assignment.
halcheck: (./ArbitrationSubModule_Testbench.v,454): Assigned using blocking assignment in this process.
		clk = 0;
|
halcheck: *W,IMPDTC (./ArbitrationSubModule_Testbench.v,423|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit ArbitrationSubModule_Testbench.
		clk = 0;
|
halcheck: *W,INTTOB (./ArbitrationSubModule_Testbench.v,423|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit ArbitrationSubModule_Testbench.
		clk = 0;
|
halcheck: *W,TRUNCZ (./ArbitrationSubModule_Testbench.v,423|0): Truncation in constant conversion without a loss of bits in module/design-unit ArbitrationSubModule_Testbench.
		clk = 0;
|
halcheck: *W,REVROP (./ArbitrationSubModule_Testbench.v,423|0): Register 'clk' is being read/assigned outside the process in which it was assigned using a blocking assignment.
halcheck: (./ArbitrationSubModule_Testbench.v,452): Assigned using blocking assignment in this process.
		reset = 1;
|
halcheck: *W,IMPDTC (./ArbitrationSubModule_Testbench.v,424|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit ArbitrationSubModule_Testbench.
		reset = 1;
|
halcheck: *W,INTTOB (./ArbitrationSubModule_Testbench.v,424|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit ArbitrationSubModule_Testbench.
		reset = 1;
|
halcheck: *W,TRUNCZ (./ArbitrationSubModule_Testbench.v,424|0): Truncation in constant conversion without a loss of bits in module/design-unit ArbitrationSubModule_Testbench.
		tb_P_InstMem_Address	= 'h1;
|
halcheck: *W,IMPTYP (./ArbitrationSubModule_Testbench.v,428|0): Expression ''h1' implicitly converted to type 'register' from type 'integer'.
		#100 reset = 0;
|
halcheck: *W,IMPDTC (./ArbitrationSubModule_Testbench.v,432|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit ArbitrationSubModule_Testbench.
		#100 reset = 0;
|
halcheck: *W,INTTOB (./ArbitrationSubModule_Testbench.v,432|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit ArbitrationSubModule_Testbench.
		#100 reset = 0;
|
halcheck: *W,TRUNCZ (./ArbitrationSubModule_Testbench.v,432|0): Truncation in constant conversion without a loss of bits in module/design-unit ArbitrationSubModule_Testbench.
		#200 tb_P_InstMem_Address	= 32'd5;	
|
halcheck: *W,TRUNCZ (./ArbitrationSubModule_Testbench.v,437|0): Truncation in constant conversion without a loss of bits in module/design-unit ArbitrationSubModule_Testbench.
always #50 clk = !clk;
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,452|0): Missing begin/end statement in the 'always' block.
always #50 clk = !clk;
|
halcheck: *W,EVTRIG (./ArbitrationSubModule_Testbench.v,452|0): Always block with no event trigger at the start of the block in module 'ArbitrationSubModule_Testbench'.
always #50 clk = !clk;
|
halcheck: *W,SEPLIN (./ArbitrationSubModule_Testbench.v,452|0): Use a separate line for each HDL statement.
always #50 clk = !clk;
|
halcheck: *W,RDBFAS (./ArbitrationSubModule_Testbench.v,452|0): Register 'clk', assigned using blocking assignment, is being read before getting assigned.
always #100 heartbeat = !heartbeat;	
|
halcheck: *W,NBGEND (./ArbitrationSubModule_Testbench.v,454|0): Missing begin/end statement in the 'always' block.
always #100 heartbeat = !heartbeat;	
|
halcheck: *W,EVTRIG (./ArbitrationSubModule_Testbench.v,454|0): Always block with no event trigger at the start of the block in module 'ArbitrationSubModule_Testbench'.
always #100 heartbeat = !heartbeat;	
|
halcheck: *W,SEPLIN (./ArbitrationSubModule_Testbench.v,454|0): Use a separate line for each HDL statement.
always #100 heartbeat = !heartbeat;	
|
halcheck: *W,RDBFAS (./ArbitrationSubModule_Testbench.v,454|0): Register 'heartbeat', assigned using blocking assignment, is being read before getting assigned.
ArbitrationSubModule uut(
|
halcheck: *N,IDLENG (./ArbitrationSubModule_Testbench.v,93|0): Identifier name 'uut' is not of appropriate length (4 to 16 characters).
module ArbitrationSubModule(
|
halcheck: *N,IDLENG (./ArbitrationSubModule.v,80|0): Identifier name 'ArbitrationSubModule' is not of appropriate length (4 to 16 characters).
* File			: ArbitrationSubModule.v
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,4|0): HDL source line contains one or more control characters.
* Project 		: Univeristy of Patras, Computer engineering & informatics dept.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,5|0): HDL source line contains one or more control characters.
*			 	  Design of a multicore system based on the mips32 processor.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,6|0): HDL source line contains one or more control characters.
* Creator(s)	: Odysseas Papadakis	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,7|0): HDL source line contains one or more control characters.
*				
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,10|0): HDL source line contains one or more control characters.
*				An arbitration submodule stands between each processor and the system buses ( Data and Instruction ).
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,11|0): HDL source line contains one or more control characters.
*				An arbitration submodule stands between each processor and the system buses ( Data and Instruction ).
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,11|0): The HDL source line is 106 characters, which exceeds the recommended length of 80 characters.
				The 2 buses of the system are shared by all the arbitration modules.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,12|0): HDL source line contains one or more control characters.
*	---DELETE	The two buses are independent of eachother and can therefore be used simultaneously.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,13|0): HDL source line contains one or more control characters.
*	---DELETE	The two buses are independent of eachother and can therefore be used simultaneously.
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,13|0): The HDL source line is 96 characters, which exceeds the recommended length of 80 characters.
*				
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,14|0): HDL source line contains one or more control characters.
*				The modules job  is to either isolate the processor from the bus, or connect it to the bus.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,16|0): HDL source line contains one or more control characters.
*				The modules job  is to either isolate the processor from the bus, or connect it to the bus.
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,16|0): The HDL source line is 96 characters, which exceeds the recommended length of 80 characters.
			1) 	Initially, the arbitration module isolates its processor from the buses.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,20|0): HDL source line contains one or more control characters.
				The requests signals to the Arbiter are LOW ( D_Bus_RQ, I_Bus_RQ)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,21|0): HDL source line contains one or more control characters.
				At this point the inputs from the Arbiter should be LOW for both Grant signals ( D_Bus_GRANT, I_Bus_GRANT).
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,22|0): HDL source line contains one or more control characters.
				At this point the inputs from the Arbiter should be LOW for both Grant signals ( D_Bus_GRANT, I_Bus_GRANT).
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,22|0): The HDL source line is 111 characters, which exceeds the recommended length of 80 characters.
				It feeds zeroes to the inputs of the processor.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,23|0): HDL source line contains one or more control characters.
	----PROBLEM? ( are the zeroes being fed to the buses )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,25|0): HDL source line contains one or more control characters.
	----ANSWER	(no, the inputs from the buses are inputs to a MUX . Source :Synthesis)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,26|0): HDL source line contains one or more control characters.
	----ANSWER	(no, the inputs from the buses are inputs to a MUX . Source :Synthesis)
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,26|0): The HDL source line is 83 characters, which exceeds the recommended length of 80 characters.
				And puts the tri state buffers of its outputs facing the buses at HIGH-Z.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,28|0): HDL source line contains one or more control characters.
				Therefore the processor does not have access to the data being circulated on the bus 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,29|0): HDL source line contains one or more control characters.
				Therefore the processor does not have access to the data being circulated on the bus 
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,29|0): The HDL source line is 89 characters, which exceeds the recommended length of 80 characters.
				and the bus can not be driven by the processor.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,30|0): HDL source line contains one or more control characters.
*			2)	When a processor want to use a BUS, it raises one of the following signals to HIGH:
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,32|0): HDL source line contains one or more control characters.
*			2)	When a processor want to use a BUS, it raises one of the following signals to HIGH:
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,32|0): The HDL source line is 90 characters, which exceeds the recommended length of 80 characters.
*				
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,33|0): HDL source line contains one or more control characters.
*				(  For the Data Bus )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,34|0): HDL source line contains one or more control characters.
*				P_DataMem_Read
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,35|0): HDL source line contains one or more control characters.
*				P_DataMem_Write
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,36|0): HDL source line contains one or more control characters.
*				P_DataMem_Address
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,37|0): HDL source line contains one or more control characters.
*				P_DataMem_Out
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,38|0): HDL source line contains one or more control characters.
				( For the Instruction Bus )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,40|0): HDL source line contains one or more control characters.
				P_InstMem_Read
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,41|0): HDL source line contains one or more control characters.
*				
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,42|0): HDL source line contains one or more control characters.
				The module will in turn raise the appropriate signal to HIGH
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,43|0): HDL source line contains one or more control characters.
				D_Bus_RQ - Goes HIGH to signal to the arbiter that the processor wants to use the Data Bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,44|0): HDL source line contains one or more control characters.
				D_Bus_RQ - Goes HIGH to signal to the arbiter that the processor wants to use the Data Bus
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,44|0): The HDL source line is 94 characters, which exceeds the recommended length of 80 characters.
				I_Bus_RQ - Goes HIGH to signal to the arbiter that the processor wants to use the Instruction Bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,45|0): HDL source line contains one or more control characters.
				I_Bus_RQ - Goes HIGH to signal to the arbiter that the processor wants to use the Instruction Bus
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,45|0): The HDL source line is 101 characters, which exceeds the recommended length of 80 characters.
				Then the module will wait for the Arbiter to give it the instruction to connect the processor to the bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,47|0): HDL source line contains one or more control characters.
				Then the module will wait for the Arbiter to give it the instruction to connect the processor to the bus
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,47|0): The HDL source line is 108 characters, which exceeds the recommended length of 80 characters.
			3)	When the Arbiter drives the grant signal HIGH ( either for the data or the instruction bus)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,49|0): HDL source line contains one or more control characters.
			3)	When the Arbiter drives the grant signal HIGH ( either for the data or the instruction bus)
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,49|0): The HDL source line is 97 characters, which exceeds the recommended length of 80 characters.
				The arbitration module allows the bus from the data to drive the inputs of the processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,50|0): HDL source line contains one or more control characters.
				The arbitration module allows the bus from the data to drive the inputs of the processor
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,50|0): The HDL source line is 92 characters, which exceeds the recommended length of 80 characters.
				and switches from showing HIGH-Z to the buses, to connecting the bus with the outputs of the processor.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,51|0): HDL source line contains one or more control characters.
				and switches from showing HIGH-Z to the buses, to connecting the bus with the outputs of the processor.
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,51|0): The HDL source line is 107 characters, which exceeds the recommended length of 80 characters.
*				When no R/W signals are HIGH from the processor, the outputs of the module touching the Bus are set to HIGH-Z.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,56|0): HDL source line contains one or more control characters.
*				When no R/W signals are HIGH from the processor, the outputs of the module touching the Bus are set to HIGH-Z.
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,56|0): The HDL source line is 115 characters, which exceeds the recommended length of 80 characters.
*				Additionally the outputs connected to the processor are all LOW. Indicating that there is no data for the 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,57|0): HDL source line contains one or more control characters.
*				Additionally the outputs connected to the processor are all LOW. Indicating that there is no data for the 
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,57|0): The HDL source line is 111 characters, which exceeds the recommended length of 80 characters.
*				processor to Grab. 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,58|0): HDL source line contains one or more control characters.
*				(we can call this the idle state)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,59|0): HDL source line contains one or more control characters.
*				When any R/W signal goes HIGH from the processor, the Arbitration module sends a Bus Request (Bus_RQ)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,61|0): HDL source line contains one or more control characters.
*				When any R/W signal goes HIGH from the processor, the Arbitration module sends a Bus Request (Bus_RQ)
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,61|0): The HDL source line is 106 characters, which exceeds the recommended length of 80 characters.
*				to the Bus Arbiter , for the corresponding Bus.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,62|0): HDL source line contains one or more control characters.
*				(we can call this the request_sent state)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,63|0): HDL source line contains one or more control characters.
*				Once the Bus Arbiter sets Bus_Grant to HIGH,  the BUS is ours. 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,65|0): HDL source line contains one or more control characters.
*				The outputs of the processor are allowed to drive the Bus. Additionally the inputs of the processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,66|0): HDL source line contains one or more control characters.
*				The outputs of the processor are allowed to drive the Bus. Additionally the inputs of the processor
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,66|0): The HDL source line is 104 characters, which exceeds the recommended length of 80 characters.
*				are allowed to be driven by the bus.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,67|0): HDL source line contains one or more control characters.
*				(we can call this the bus_connected state )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,68|0): HDL source line contains one or more control characters.
*				
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,70|0): HDL source line contains one or more control characters.
*				Once the Bus Arbiter sets Bus_Grant to LOW,  the processor is disconnected from the bus.
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,71|0): HDL source line contains one or more control characters.
*				Once the Bus Arbiter sets Bus_Grant to LOW,  the processor is disconnected from the bus.
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,71|0): The HDL source line is 93 characters, which exceeds the recommended length of 80 characters.
*				We return to the idle state
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,72|0): HDL source line contains one or more control characters.
// Data Memory Interface	---------------------------------------------------
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,82|0): HDL source line contains one or more control characters.
	//	Bus Signals 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,84|0): HDL source line contains one or more control characters.
		//	Bus --> Arbitration SubModule
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,86|0): HDL source line contains one or more control characters.
		input	[31:0]	Bus_DataMem_In,		//	( Memory Content Signal )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,87|0): HDL source line contains one or more control characters.
		input			Bus_DataMem_Ready,	//	( Memory Control Signal )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,88|0): HDL source line contains one or more control characters.
		//	Arbitration SubModule --> Bus		( Memory Control Signals )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,90|0): HDL source line contains one or more control characters.
		output			Bus_DataMem_Read,		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,91|0): HDL source line contains one or more control characters.
		output	[3:0] 	Bus_DataMem_Write,		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,92|0): HDL source line contains one or more control characters.
		output	[29:0]	Bus_DataMem_Address,	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,93|0): HDL source line contains one or more control characters.
		output	[31:0]	Bus_DataMem_Out,		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,94|0): HDL source line contains one or more control characters.
	//	Processor Signals
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,97|0): HDL source line contains one or more control characters.
		// Processor --> Arbitration SubModule  	( Memory Control Signals )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,99|0): HDL source line contains one or more control characters.
		input 			P_DataMem_Read,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,100|0): HDL source line contains one or more control characters.
		input	[3:0]   P_DataMem_Write,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,101|0): HDL source line contains one or more control characters.
		input	[29:0]	P_DataMem_Address,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,102|0): HDL source line contains one or more control characters.
		input	[31:0]	P_DataMem_Out,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,103|0): HDL source line contains one or more control characters.
		// Arbitration SubModule --> Processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,105|0): HDL source line contains one or more control characters.
		output	[31:0]	P_DataMem_In,		//	( Memory Content Signal )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,106|0): HDL source line contains one or more control characters.
		output			P_DataMem_Ready,	//	( Memory Control Signal )
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,107|0): HDL source line contains one or more control characters.
	//	Arbiter Signals
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,110|0): HDL source line contains one or more control characters.
		// Bus Arbiter --> Arbitration SubModule
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,112|0): HDL source line contains one or more control characters.
		input	D_Bus_GRANT,   
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,113|0): HDL source line contains one or more control characters.
		// Arbitration SubModule --> Bus Arbiter
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,114|0): HDL source line contains one or more control characters.
		output	D_Bus_RQ,		 	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,115|0): HDL source line contains one or more control characters.
// Instruction Memory Interface  ------------------------------------------------  
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,118|0): The HDL source line is 83 characters, which exceeds the recommended length of 80 characters.
	//	Bus Signals
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,120|0): HDL source line contains one or more control characters.
		//	Bus --> Arbitration SubModule
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,123|0): HDL source line contains one or more control characters.
		input			Bus_InstMem_Ready,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,124|0): HDL source line contains one or more control characters.
		input	[31:0]	Bus_InstMem_In,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,125|0): HDL source line contains one or more control characters.
		//	Arbitration SubModule --> Bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,127|0): HDL source line contains one or more control characters.
		output	[29:0]	Bus_InstMem_Address,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,128|0): HDL source line contains one or more control characters.
		output			Bus_InstMem_Read,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,129|0): HDL source line contains one or more control characters.
	//	Processor Signals	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,131|0): HDL source line contains one or more control characters.
		// Processor --> Arbitration SubModule
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,133|0): HDL source line contains one or more control characters.
		input	[29:0]	P_InstMem_Address,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,134|0): HDL source line contains one or more control characters.
		input			P_InstMem_Read,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,135|0): HDL source line contains one or more control characters.
		// Arbitration SubModule --> Processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,137|0): HDL source line contains one or more control characters.
		output			P_InstMem_Ready,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,138|0): HDL source line contains one or more control characters.
		output	[31:0]	P_InstMem_In,
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,139|0): HDL source line contains one or more control characters.
	//	Arbiter Signals
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,142|0): HDL source line contains one or more control characters.
		 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,144|0): HDL source line contains one or more control characters.
		//Bus Arbiter --> Arbitration SubModule
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,145|0): HDL source line contains one or more control characters.
		input	I_Bus_GRANT,  
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,146|0): HDL source line contains one or more control characters.
		// Arbitration SubModule --> Bus Arbiter
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,148|0): HDL source line contains one or more control characters.
		output	I_Bus_RQ   
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,149|0): HDL source line contains one or more control characters.
		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,150|0): HDL source line contains one or more control characters.
	);  
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,151|0): HDL source line contains one or more control characters.
	      
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,154|0): HDL source line contains one or more control characters.
	// Instruction Memory Interface Assignments  ---------------------------------------------------------------
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,155|0): HDL source line contains one or more control characters.
	// Instruction Memory Interface Assignments  ---------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,155|0): The HDL source line is 109 characters, which exceeds the recommended length of 80 characters.
		//Arbitration SubModule --> Bus Arbiter
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,157|0): HDL source line contains one or more control characters.
	  	assign I_Bus_RQ = P_InstMem_Read ; // When the processor wants an instruction, request the Instruction bus from the Bus Arbiter 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,158|0): HDL source line contains one or more control characters.
	  	assign I_Bus_RQ = P_InstMem_Read ; // When the processor wants an instruction, request the Instruction bus from the Bus Arbiter 
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,158|0): The HDL source line is 132 characters, which exceeds the recommended length of 80 characters.
		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,159|0): HDL source line contains one or more control characters.
		//Arbitration SubModule --> Instruction Bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,160|0): HDL source line contains one or more control characters.
	  	assign Bus_InstMem_Read		= 	(I_Bus_GRANT) ? P_InstMem_Read			: 1'bz;  // When Grant is LOW, set the bus outputs  to HIGH-Z
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,161|0): HDL source line contains one or more control characters.
	  	assign Bus_InstMem_Read		= 	(I_Bus_GRANT) ? P_InstMem_Read			: 1'bz;  // When Grant is LOW, set the bus outputs  to HIGH-Z
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,161|0): The HDL source line is 126 characters, which exceeds the recommended length of 80 characters.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,162|0): HDL source line contains one or more control characters.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,162|0): The HDL source line is 115 characters, which exceeds the recommended length of 80 characters.
	  	//Arbitration SubModule --> Processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,164|0): HDL source line contains one or more control characters.
	  	assign P_InstMem_Ready		= 	(I_Bus_GRANT) ? Bus_InstMem_Ready 		: 1'b0;	 // When Grant is LOW, Tell the processor: Instruction is not ready
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,165|0): HDL source line contains one or more control characters.
	  	assign P_InstMem_Ready		= 	(I_Bus_GRANT) ? Bus_InstMem_Ready 		: 1'b0;	 // When Grant is LOW, Tell the processor: Instruction is not ready
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,165|0): The HDL source line is 142 characters, which exceeds the recommended length of 80 characters.
	  	assign P_InstMem_In 		=	(I_Bus_GRANT) ? Bus_InstMem_In			: 32'b0; // When Grant is LOW, show zeros to the processor						 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,166|0): HDL source line contains one or more control characters.
	  	assign P_InstMem_In 		=	(I_Bus_GRANT) ? Bus_InstMem_In			: 32'b0; // When Grant is LOW, show zeros to the processor						 
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,166|0): The HDL source line is 126 characters, which exceeds the recommended length of 80 characters.
	  	assign P_InstMem_In 		=	(I_Bus_GRANT) ? Bus_InstMem_In			: 32'b0; // When Grant is LOW, show zeros to the processor						 
|
halcheck: *W,BITUNS (./ArbitrationSubModule.v,166|0): Not all bits of constant '32'b0' are explicitly specified.
halcheck: (./ArbitrationSubModule.v,166): Constant extended by 31 bits to -> 32'b(0000000000000000000000000000000)0.
	  	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,167|0): HDL source line contains one or more control characters.
	  	// POSSIBLE PROBLEM 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,168|0): HDL source line contains one or more control characters.
	  	// are we driving the bus to zero as well? or just the processor signals ?
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,169|0): HDL source line contains one or more control characters.
	  	// See how it is synthesized, might need an inout port instead of input ( Bus_InstMem_In)
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,170|0): HDL source line contains one or more control characters.
	  	// See how it is synthesized, might need an inout port instead of input ( Bus_InstMem_In)
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,170|0): The HDL source line is 93 characters, which exceeds the recommended length of 80 characters.
	  	// If the processor signal is muxed between BuS_InstMem_In and HIGH-Z, it's fine
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,171|0): HDL source line contains one or more control characters.
	  	// If the processor signal is muxed between BuS_InstMem_In and HIGH-Z, it's fine
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,171|0): The HDL source line is 84 characters, which exceeds the recommended length of 80 characters.
	 // Data memory Interface Assignments  --------------------------------------------------------------------
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,174|0): HDL source line contains one or more control characters.
	 // Data memory Interface Assignments  --------------------------------------------------------------------
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,174|0): The HDL source line is 108 characters, which exceeds the recommended length of 80 characters.
	 	//Arbitration SubModule --> Bus Arbiter
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,176|0): HDL source line contains one or more control characters.
	 	// When the processor wants some Data, request to use the Data bus from the Bus Arbiter
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,177|0): HDL source line contains one or more control characters.
	 	// When the processor wants some Data, request to use the Data bus from the Bus Arbiter
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,177|0): The HDL source line is 90 characters, which exceeds the recommended length of 80 characters.
	 	assign D_Bus_RQ = ( P_DataMem_Read | P_DataMem_Write[3] | P_DataMem_Write[2] | P_DataMem_Write[1] | P_DataMem_Write[0]);
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,178|0): HDL source line contains one or more control characters.
	 	assign D_Bus_RQ = ( P_DataMem_Read | P_DataMem_Write[3] | P_DataMem_Write[2] | P_DataMem_Write[1] | P_DataMem_Write[0]);
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,178|0): The HDL source line is 123 characters, which exceeds the recommended length of 80 characters.
	 	//Arbitration SubModule --> Data Bus	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,181|0): HDL source line contains one or more control characters.
		assign Bus_DataMem_Read			= 	(D_Bus_GRANT) ? P_DataMem_Read 		: 1'bz;  // When Grant is LOW, show HIGH-Z to the bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,182|0): HDL source line contains one or more control characters.
		assign Bus_DataMem_Read			= 	(D_Bus_GRANT) ? P_DataMem_Read 		: 1'bz;  // When Grant is LOW, show HIGH-Z to the bus
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,182|0): The HDL source line is 117 characters, which exceeds the recommended length of 80 characters.
		assign Bus_DataMem_Write		= 	(D_Bus_GRANT) ? P_DataMem_Write		: 4'bz;	 // 
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,183|0): HDL source line contains one or more control characters.
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,184|0): HDL source line contains one or more control characters.
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,184|0): The HDL source line is 120 characters, which exceeds the recommended length of 80 characters.
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,185|0): HDL source line contains one or more control characters.
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,185|0): The HDL source line is 114 characters, which exceeds the recommended length of 80 characters.
	 	//Arbitration SubModule --> Processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,188|0): HDL source line contains one or more control characters.
		assign P_DataMem_Ready 			=	(D_Bus_GRANT) ? Bus_DataMem_Ready	: 1'b0;  // When Grant is LOW, Tell the processor memory is not ready
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,189|0): HDL source line contains one or more control characters.
		assign P_DataMem_Ready 			=	(D_Bus_GRANT) ? Bus_DataMem_Ready	: 1'b0;  // When Grant is LOW, Tell the processor memory is not ready
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,189|0): The HDL source line is 133 characters, which exceeds the recommended length of 80 characters.
		assign P_DataMem_In 			= 	(D_Bus_GRANT) ? Bus_DataMem_In		: 32'b0; // When Grant is LOW, show zeros to the processor
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,190|0): HDL source line contains one or more control characters.
		assign P_DataMem_In 			= 	(D_Bus_GRANT) ? Bus_DataMem_In		: 32'b0; // When Grant is LOW, show zeros to the processor
|
halcheck: *W,MAXLEN (./ArbitrationSubModule.v,190|0): The HDL source line is 118 characters, which exceeds the recommended length of 80 characters.
		assign P_DataMem_In 			= 	(D_Bus_GRANT) ? Bus_DataMem_In		: 32'b0; // When Grant is LOW, show zeros to the processor
|
halcheck: *W,BITUNS (./ArbitrationSubModule.v,190|0): Not all bits of constant '32'b0' are explicitly specified.
halcheck: (./ArbitrationSubModule.v,190): Constant extended by 31 bits to -> 32'b(0000000000000000000000000000000)0.
		
|
halcheck: *W,CTLCHR (./ArbitrationSubModule.v,191|0): HDL source line contains one or more control characters.
module ArbitrationSubModule(
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,80|0): Module name 'ArbitrationSubModule' uses uppercase characters.
module ArbitrationSubModule(
|
halcheck: *N,PRTCNT (./ArbitrationSubModule.v,80|0): Module/Entity 'ArbitrationSubModule' contains '24' ports.
halcheck: (./ArbitrationSubModule.v,80): Number of Input ports: 12.
halcheck: (./ArbitrationSubModule.v,80): Number of Output ports: 12.
		input	[31:0]	Bus_DataMem_In,		//	( Memory Content Signal )
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,87|0): Numeric value '31' used for identifier 'Bus_DataMem_In'. Use constants to avoid portability issues.
		output	[3:0] 	Bus_DataMem_Write,		
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,92|0): Numeric value '3' used for identifier 'Bus_DataMem_Write'. Use constants to avoid portability issues.
		output	[29:0]	Bus_DataMem_Address,	
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,93|0): Numeric value '29' used for identifier 'Bus_DataMem_Address'. Use constants to avoid portability issues.
		output	[31:0]	Bus_DataMem_Out,		
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,94|0): Numeric value '31' used for identifier 'Bus_DataMem_Out'. Use constants to avoid portability issues.
		input	[3:0]   P_DataMem_Write,
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,101|0): Numeric value '3' used for identifier 'P_DataMem_Write'. Use constants to avoid portability issues.
		input	[29:0]	P_DataMem_Address,
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,102|0): Numeric value '29' used for identifier 'P_DataMem_Address'. Use constants to avoid portability issues.
		input	[31:0]	P_DataMem_Out,
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,103|0): Numeric value '31' used for identifier 'P_DataMem_Out'. Use constants to avoid portability issues.
		output	[31:0]	P_DataMem_In,		//	( Memory Content Signal )
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,106|0): Numeric value '31' used for identifier 'P_DataMem_In'. Use constants to avoid portability issues.
		input	[31:0]	Bus_InstMem_In,
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,125|0): Numeric value '31' used for identifier 'Bus_InstMem_In'. Use constants to avoid portability issues.
		output	[29:0]	Bus_InstMem_Address,
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,128|0): Numeric value '29' used for identifier 'Bus_InstMem_Address'. Use constants to avoid portability issues.
		input	[29:0]	P_InstMem_Address,
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,134|0): Numeric value '29' used for identifier 'P_InstMem_Address'. Use constants to avoid portability issues.
		output	[31:0]	P_InstMem_In,
|
halcheck: *W,STYVAL (./ArbitrationSubModule.v,139|0): Numeric value '31' used for identifier 'P_InstMem_In'. Use constants to avoid portability issues.
		input	[31:0]	Bus_DataMem_In,		//	( Memory Content Signal )
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,87|0): Net name 'Bus_DataMem_In' uses uppercase characters.
		input			Bus_DataMem_Ready,	//	( Memory Control Signal )
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,88|0): Net name 'Bus_DataMem_Ready' uses uppercase characters.
		output			Bus_DataMem_Read,		
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,91|0): Net name 'Bus_DataMem_Read' uses uppercase characters.
		output	[3:0] 	Bus_DataMem_Write,		
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,92|0): Net name 'Bus_DataMem_Write' uses uppercase characters.
		output	[29:0]	Bus_DataMem_Address,	
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,93|0): Net name 'Bus_DataMem_Address' uses uppercase characters.
		output	[31:0]	Bus_DataMem_Out,		
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,94|0): Net name 'Bus_DataMem_Out' uses uppercase characters.
		input 			P_DataMem_Read,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,100|0): Net name 'P_DataMem_Read' uses uppercase characters.
		input	[3:0]   P_DataMem_Write,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,101|0): Net name 'P_DataMem_Write' uses uppercase characters.
		input	[29:0]	P_DataMem_Address,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,102|0): Net name 'P_DataMem_Address' uses uppercase characters.
		input	[31:0]	P_DataMem_Out,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,103|0): Net name 'P_DataMem_Out' uses uppercase characters.
		output	[31:0]	P_DataMem_In,		//	( Memory Content Signal )
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,106|0): Net name 'P_DataMem_In' uses uppercase characters.
		output			P_DataMem_Ready,	//	( Memory Control Signal )
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,107|0): Net name 'P_DataMem_Ready' uses uppercase characters.
		input	D_Bus_GRANT,   
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,113|0): Net name 'D_Bus_GRANT' uses uppercase characters.
		output	D_Bus_RQ,		 	
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,115|0): Net name 'D_Bus_RQ' uses uppercase characters.
		input			Bus_InstMem_Ready,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,124|0): Net name 'Bus_InstMem_Ready' uses uppercase characters.
		input	[31:0]	Bus_InstMem_In,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,125|0): Net name 'Bus_InstMem_In' uses uppercase characters.
		output	[29:0]	Bus_InstMem_Address,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,128|0): Net name 'Bus_InstMem_Address' uses uppercase characters.
		output			Bus_InstMem_Read,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,129|0): Net name 'Bus_InstMem_Read' uses uppercase characters.
		input	[29:0]	P_InstMem_Address,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,134|0): Net name 'P_InstMem_Address' uses uppercase characters.
		input			P_InstMem_Read,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,135|0): Net name 'P_InstMem_Read' uses uppercase characters.
		output			P_InstMem_Ready,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,138|0): Net name 'P_InstMem_Ready' uses uppercase characters.
		output	[31:0]	P_InstMem_In,
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,139|0): Net name 'P_InstMem_In' uses uppercase characters.
		input	I_Bus_GRANT,  
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,146|0): Net name 'I_Bus_GRANT' uses uppercase characters.
		output	I_Bus_RQ   
|
halcheck: *W,LCVARN (./ArbitrationSubModule.v,149|0): Net name 'I_Bus_RQ' uses uppercase characters.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halcheck: *W,SYNTXZ (./ArbitrationSubModule.v,162|0): Synthesizing 'x'/'z' values in module 'ArbitrationSubModule'.
		assign Bus_DataMem_Write		= 	(D_Bus_GRANT) ? P_DataMem_Write		: 4'bz;	 // 
|
halcheck: *W,SYNTXZ (./ArbitrationSubModule.v,183|0): Synthesizing 'x'/'z' values in module 'ArbitrationSubModule'.
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halcheck: *W,SYNTXZ (./ArbitrationSubModule.v,184|0): Synthesizing 'x'/'z' values in module 'ArbitrationSubModule'.
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halcheck: *W,SYNTXZ (./ArbitrationSubModule.v,185|0): Synthesizing 'x'/'z' values in module 'ArbitrationSubModule'.
localparam	Pseudo_I_Arbiter_State_Wait_MEM_LOW 	= 2'b11 ;
|
halcheck: *W,USEPAR (./ArbitrationSubModule_Testbench.v,209|0): Parameter 'Pseudo_I_Arbiter_State_Wait_MEM_LOW' defined in module 'ArbitrationSubModule_Testbench' is unused.
		wire	[31:0]	tb_P_DataMem_In;
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,36|0): Wire 'tb_P_DataMem_In' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire			tb_P_DataMem_Ready;
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,37|0): Wire 'tb_P_DataMem_Ready' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire			tb_P_InstMem_Ready;
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,47|0): Wire 'tb_P_InstMem_Ready' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire	[31:0]	tb_P_InstMem_In;
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,48|0): Wire 'tb_P_InstMem_In' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire			tb_Bus_DataMem_Read;		
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,62|0): Wire 'tb_Bus_DataMem_Read' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire	[3:0] 	tb_Bus_DataMem_Write;		
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,63|0): Wire 'tb_Bus_DataMem_Write' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire	[29:0]	tb_Bus_DataMem_Address;	
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,64|0): Wire 'tb_Bus_DataMem_Address' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire	[31:0]	tb_Bus_DataMem_Out;		
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,65|0): Wire 'tb_Bus_DataMem_Out' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		wire	tb_D_Bus_RQ;		 	
|
halcheck: *W,URDWIR (./ArbitrationSubModule_Testbench.v,82|0): Wire 'tb_D_Bus_RQ' defined in module 'ArbitrationSubModule_Testbench' does not drive any object, but is assigned at least once.
		reg 		tb_P_DataMem_Read;
|
halcheck: *W,UASREG (./ArbitrationSubModule_Testbench.v,30|0): Local register variable 'tb_P_DataMem_Read' is unassigned, but is read at least once in module 'ArbitrationSubModule_Testbench'.
		reg	[3:0]   tb_P_DataMem_Write;
|
halcheck: *W,UASREG (./ArbitrationSubModule_Testbench.v,31|0): Local register variable 'tb_P_DataMem_Write' is unassigned, but is read at least once in module 'ArbitrationSubModule_Testbench'.
		reg	[29:0]	tb_P_DataMem_Address;
|
halcheck: *W,UASREG (./ArbitrationSubModule_Testbench.v,32|0): Local register variable 'tb_P_DataMem_Address' is unassigned, but is read at least once in module 'ArbitrationSubModule_Testbench'.
		reg	[31:0]	tb_P_DataMem_Out;
|
halcheck: *W,UASREG (./ArbitrationSubModule_Testbench.v,33|0): Local register variable 'tb_P_DataMem_Out' is unassigned, but is read at least once in module 'ArbitrationSubModule_Testbench'.
		reg	[31:0]	tb_Bus_DataMem_In;		
|
halcheck: *W,UASREG (./ArbitrationSubModule_Testbench.v,58|0): Local register variable 'tb_Bus_DataMem_In' is unassigned, but is read at least once in module 'ArbitrationSubModule_Testbench'.
		reg			tb_Bus_DataMem_Ready;	
|
halcheck: *W,UASREG (./ArbitrationSubModule_Testbench.v,59|0): Local register variable 'tb_Bus_DataMem_Ready' is unassigned, but is read at least once in module 'ArbitrationSubModule_Testbench'.
		reg		tb_D_Bus_GRANT;
|
halcheck: *W,UASREG (./ArbitrationSubModule_Testbench.v,83|0): Local register variable 'tb_D_Bus_GRANT' is unassigned, but is read at least once in module 'ArbitrationSubModule_Testbench'.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halcheck: *W,EXTENZ (./ArbitrationSubModule.v,162|0): Extension of 'z' bits in a constant.
		assign Bus_DataMem_Write		= 	(D_Bus_GRANT) ? P_DataMem_Write		: 4'bz;	 // 
|
halcheck: *W,EXTENZ (./ArbitrationSubModule.v,183|0): Extension of 'z' bits in a constant.
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halcheck: *W,EXTENZ (./ArbitrationSubModule.v,184|0): Extension of 'z' bits in a constant.
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halcheck: *W,EXTENZ (./ArbitrationSubModule.v,185|0): Extension of 'z' bits in a constant.
module ArbitrationSubModule_Testbench;
|
halcheck: *W,MULTMS (./ArbitrationSubModule_Testbench.v,16|0): Multiple timescales exist in the design.
halcheck: (./ArbitrationSubModule_Testbench.v,16): Module 'ArbitrationSubModule_Testbench' has timeunit/timeprecesion in 1ns/1ns.
halcheck: (./ArbitrationSubModule.v,80): Module 'ArbitrationSubModule' has timeunit/timeprecesion in 1ns/1ps.
halcheck: Total errors   = 0.
halcheck: Total warnings = 588.

  ==========================================================================
Performing synthesizability checks 

cfe64: 15.20.038-s(15.20.s038): (c) Copyright 1995 - 2017 Cadence Design Systems, Inc.
cfe64 Build : Wed Oct 18 00:02:45 IST 2017 ldvopt215
halsynth: Loading design snapshot....
halsynth: Traversing design hierarchy....
initial		// Instruction initial block
|
halsynth: *W,INIUSP (./ArbitrationSubModule_Testbench.v,418|0): Module ArbitrationSubModule_Testbench has an initial block or a variable declaration assignment, which is ignored by synthesis tools.
always #50 clk = !clk;
|
halsynth: *E,AWNDEL (./ArbitrationSubModule_Testbench.v,452|0): Always block with no event trigger at the start in module ArbitrationSubModule_Testbench.
always #100 heartbeat = !heartbeat;	
|
halsynth: *E,AWNDEL (./ArbitrationSubModule_Testbench.v,454|0): Always block with no event trigger at the start in module ArbitrationSubModule_Testbench.
always@(*)
|
halsynth: *W,LATBAS (./ArbitrationSubModule_Testbench.v,300|0): In module/design-unit ArbitrationSubModule_Testbench, latch is assigned by blocking assignments.
always@(*)
|
halsynth: *W,LATMLG (./ArbitrationSubModule_Testbench.v,300|0): The latches 'tb_Bus_InstMem_In, tb_Bus_InstMem_Ready' in the process/always block are mixed with combinational logic.
halsynth: *W,COMBLP: In module ArbitrationSubModule_Testbench, combinational loop detected for node clk.
always #50 clk = !clk;
|
halsynth: (./ArbitrationSubModule_Testbench.v,452|0): Source HDL information for the error/warning mentioned above.
halsynth: *W,COMBLP: In module ArbitrationSubModule_Testbench, combinational loop detected for node heartbeat.
always #100 heartbeat = !heartbeat;	
|
halsynth: (./ArbitrationSubModule_Testbench.v,454|0): Source HDL information for the error/warning mentioned above.
				#50 Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_RQ_HIGH;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,235|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
			#50  tb_I_Bus_Arbiter_GRANT = 1'b1;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,243|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
					#50 Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_RQ_LOW  ;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,247|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
			#50  tb_I_Bus_Arbiter_GRANT = 1'b0;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,255|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
			#50  Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_Idle  ;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,256|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
			#50 tb_Bus_InstMem_In = 32'd1;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,307|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
			#25 tb_Bus_InstMem_Ready = 0'b0;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,310|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
				#50 Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Read_HIGH;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,315|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
			#50 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 32'd4;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,324|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
			#50 tb_Bus_InstMem_Ready = 1'b1;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,327|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
					#50 Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Idle  ;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,332|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
always #50 clk = !clk;
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,452|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
always #100 heartbeat = !heartbeat;	
|
halsynth: *W,IGNDLY (./ArbitrationSubModule_Testbench.v,454|0): Lumped delay in module 'ArbitrationSubModule_Testbench' is ignored.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halsynth: *N,FSMIDN (./ArbitrationSubModule_Testbench.v,219|0): In module/design-unit 'ArbitrationSubModule_Testbench', FSM for state register 'Pseudo_I_Arbiter_Current_State' has been recognized.
	Pseudo_I_Arbiter_State_RQ_HIGH:
|
halsynth: *W,TRNMBT (./ArbitrationSubModule_Testbench.v,241|0): For the specified state '1', the state value changes by more than one bits on transition to state(s): 2.
					#50 Pseudo_I_Arbiter_Next_State = Pseudo_I_Arbiter_State_RQ_LOW  ;
|
halsynth: (./ArbitrationSubModule_Testbench.v,247|0): Source HDL information for the error/warning mentioned above.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_Next_State ; // If not resetting, start sequencing the states
|
halsynth: *N,FSMIDN (./ArbitrationSubModule_Testbench.v,294|0): In module/design-unit 'ArbitrationSubModule_Testbench', FSM for state register 'Pseudo_I_Memory_Current_State' has been recognized.
module ArbitrationSubModule_Testbench;
|
halsynth: *W,EXTFSM (./ArbitrationSubModule_Testbench.v,16|0): Extraneous logic present in module/design-unit 'ArbitrationSubModule_Testbench' that encodes an FSM (multiple FSMs).
halsynth: Total errors   = 2.
halsynth: Total warnings = 20.

  ==========================================================================
Performing structural checks 

halstruct(64): 15.20-s038: (c) Copyright 1995-2017 Cadence Design Systems, Inc.
visadev(64): 15.20-s038: (c) Copyright 1995-2017 Cadence Design Systems, Inc.
reg clk;
|
halstruct: *E,CMBPAU (./ArbitrationSubModule_Testbench.v,20|0): Combinational loop detected through 'clk' in module/design-unit 'ArbitrationSubModule_Testbench'.
halstruct: (./ArbitrationSubModule_Testbench.v,452): ArbitrationSubModule_Testbench.clk.
reg heartbeat;
|
halstruct: *E,CMBPAU (./ArbitrationSubModule_Testbench.v,19|0): Combinational loop detected through 'heartbeat' in module/design-unit 'ArbitrationSubModule_Testbench'.
halstruct: (./ArbitrationSubModule_Testbench.v,454): ArbitrationSubModule_Testbench.heartbeat.
			if( (tb_Bus_InstMem_Read == 1'b1) )
|
halstruct: *W,IFXZWC (./ArbitrationSubModule_Testbench.v,314|0): Conditional expression evaluates to 'x' or 'z'.
			if(tb_Bus_InstMem_Read == 1'b0)
|
halstruct: *W,IFXZWC (./ArbitrationSubModule_Testbench.v,330|0): Conditional expression evaluates to 'x' or 'z'.
always #100 heartbeat = !heartbeat;	
|
halstruct: *N,INFNOT (./ArbitrationSubModule_Testbench.v,454|0): Ignoring wire 'heartbeat' with no fanout to module/design-unit outputs or child instances.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,ASNRST (./ArbitrationSubModule_Testbench.v,219|0): Flip-flop 'ArbitrationSubModule_Testbench.Pseudo_I_Arbiter_Current_State' has 'active_high' asynchronous set/reset 'reset' as against the recommended 'active_low' style.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *N,FFASRT (./ArbitrationSubModule_Testbench.v,219|0): Flip-flop 'Pseudo_I_Arbiter_Current_State' has an asynchronous reset 'reset'.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,CLKINP (./ArbitrationSubModule_Testbench.v,219|0): In module 'ArbitrationSubModule_Testbench', clock signal 'clk' for flip-flop 'Pseudo_I_Arbiter_Current_State' is not an input.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,RSTINP (./ArbitrationSubModule_Testbench.v,219|0): In module 'ArbitrationSubModule_Testbench', reset signal 'reset', for flip-flop 'Pseudo_I_Arbiter_Current_State', is not an input.
reg clk;
|
halstruct: *N,CLKINF (./ArbitrationSubModule_Testbench.v,20|0): Signal 'ArbitrationSubModule_Testbench.clk' was inferred as clock.
halstruct: (./ArbitrationSubModule_Testbench.v,20): Clock source is signal 'ArbitrationSubModule_Testbench.clk'.
halstruct: (./ArbitrationSubModule_Testbench.v,219): Drives the flip-flop 'ArbitrationSubModule_Testbench.Pseudo_I_Arbiter_Current_State'.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,ACNCPI (./ArbitrationSubModule_Testbench.v,219|0): Asynchronous reset 'reset' of latch/flip-flop 'ArbitrationSubModule_Testbench.Pseudo_I_Arbiter_Current_State' is not controllable from primary inputs.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,CLKNPI (./ArbitrationSubModule_Testbench.v,219|0): Flip-flop 'ArbitrationSubModule_Testbench.Pseudo_I_Arbiter_Current_State' has clock 'clk' which is not derived from primary input.
halstruct: (./ArbitrationSubModule_Testbench.v,452): Derived from local variable 'clk'.
		Pseudo_I_Arbiter_Current_State <= Pseudo_I_Arbiter_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,NEGCLK (./ArbitrationSubModule_Testbench.v,219|0): Clock signal 'ArbitrationSubModule_Testbench.clk' of flip-flop 'ArbitrationSubModule_Testbench.Pseudo_I_Arbiter_Current_State' is derived from an inverter.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,ASNRST (./ArbitrationSubModule_Testbench.v,294|0): Flip-flop 'ArbitrationSubModule_Testbench.Pseudo_I_Memory_Current_State' has 'active_high' asynchronous set/reset 'reset' as against the recommended 'active_low' style.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *N,FFASRT (./ArbitrationSubModule_Testbench.v,294|0): Flip-flop 'Pseudo_I_Memory_Current_State' has an asynchronous reset 'reset'.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *E,CBPAHI (./ArbitrationSubModule_Testbench.v,294|0): Combinatorial path crossing multiple units drives 'ArbitrationSubModule_Testbench.Pseudo_I_Memory_Current_State'.
halstruct: (./ArbitrationSubModule_Testbench.v,294): in instance 'ArbitrationSubModule_Testbench', 'Pseudo_I_Memory_Next_State' drives 'Pseudo_I_Memory_Current_State'.
halstruct: (./ArbitrationSubModule_Testbench.v,340): in instance 'ArbitrationSubModule_Testbench', combinatorial function of 'tb_Bus_InstMem_Read' drives 'Pseudo_I_Memory_Next_State'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): in instance 'ArbitrationSubModule_Testbench', output 'Bus_InstMem_Read' of instance 'uut' drives 'tb_Bus_InstMem_Read'.
halstruct: (./ArbitrationSubModule.v,161): in instance 'ArbitrationSubModule_Testbench.uut', combinatorial function drives 'Bus_InstMem_Read'.
		Pseudo_I_Memory_Current_State <= Pseudo_I_Memory_Next_State ; // If not resetting, start sequencing the states
|
halstruct: *W,NEGCLK (./ArbitrationSubModule_Testbench.v,294|0): Clock signal 'ArbitrationSubModule_Testbench.clk' of flip-flop 'ArbitrationSubModule_Testbench.Pseudo_I_Memory_Current_State' is derived from an inverter.
			#50 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 32'd4;
|
halstruct: *N,CLKINF (./ArbitrationSubModule_Testbench.v,324|0): Signal 'ArbitrationSubModule_Testbench.mux(Pseudo_I_Memory_Current_State)' was inferred as clock.
halstruct: (./ArbitrationSubModule_Testbench.v,324): Clock source is signal 'ArbitrationSubModule_Testbench.mux(Pseudo_I_Memory_Current_State)'.
halstruct: (./ArbitrationSubModule_Testbench.v,324): Drives the latch 'ArbitrationSubModule_Testbench.tb_Bus_InstMem_In'.
			#50 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 32'd4;
|
halstruct: *W,LENCPI (./ArbitrationSubModule_Testbench.v,324|0): Enable of latch 'ArbitrationSubModule_Testbench.tb_Bus_InstMem_In' is not controllable from primary inputs.
			#50 tb_Bus_InstMem_Ready = 1'b1;
|
halstruct: *N,CLKINF (./ArbitrationSubModule_Testbench.v,327|0): Signal 'ArbitrationSubModule_Testbench.mux(Pseudo_I_Memory_Current_State)' was inferred as clock.
halstruct: (./ArbitrationSubModule_Testbench.v,327): Clock source is signal 'ArbitrationSubModule_Testbench.mux(Pseudo_I_Memory_Current_State)'.
halstruct: (./ArbitrationSubModule_Testbench.v,327): Drives the latch 'ArbitrationSubModule_Testbench.tb_Bus_InstMem_Ready'.
			#50 tb_Bus_InstMem_Ready = 1'b1;
|
halstruct: *W,LENCPI (./ArbitrationSubModule_Testbench.v,327|0): Enable of latch 'ArbitrationSubModule_Testbench.tb_Bus_InstMem_Ready' is not controllable from primary inputs.
module ArbitrationSubModule(
|
halstruct: *W,TSMHOL (./ArbitrationSubModule.v,80|0): Tri-state module 'ArbitrationSubModule' contains other logic.
halstruct: (./ArbitrationSubModule.v,165): Additional logic used.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'Bus_DataMem_In' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'Bus_DataMem_In[31:0]' mapped to actual expression 'tb_Bus_DataMem_In' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'Bus_DataMem_Ready' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'Bus_DataMem_Ready' mapped to actual expression 'tb_Bus_DataMem_Ready' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'Bus_DataMem_Read' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'Bus_DataMem_Write' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'Bus_DataMem_Address' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'Bus_DataMem_Out' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'P_DataMem_Read' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Read' mapped to actual expression 'tb_P_DataMem_Read' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'P_DataMem_Write' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Write[3]' mapped to actual expression 'tb_P_DataMem_Write' which is undriven.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Write[2]' mapped to actual expression 'tb_P_DataMem_Write' which is undriven.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Write[1]' mapped to actual expression 'tb_P_DataMem_Write' which is undriven.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Write[0]' mapped to actual expression 'tb_P_DataMem_Write' which is undriven.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Write[3:0]' mapped to actual expression 'tb_P_DataMem_Write' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'P_DataMem_Address' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Address[29:0]' mapped to actual expression 'tb_P_DataMem_Address' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'P_DataMem_Out' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_DataMem_Out[31:0]' mapped to actual expression 'tb_P_DataMem_Out' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'P_DataMem_In' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'P_DataMem_Ready' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'D_Bus_GRANT' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'D_Bus_GRANT' mapped to actual expression 'tb_D_Bus_GRANT' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'D_Bus_RQ' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'P_InstMem_Address' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_InstMem_Address[29:0]' mapped to actual expression 'tb_P_InstMem_Address' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *E,UNCONI (./ArbitrationSubModule_Testbench.v,93|0): Input port 'P_InstMem_Read' of entity/module 'ArbitrationSubModule' is being used inside architecture/module, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
halstruct: (./ArbitrationSubModule_Testbench.v,93): 'P_InstMem_Read' mapped to actual expression 'tb_P_InstMem_Read' which is undriven.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'P_InstMem_Ready' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
ArbitrationSubModule uut(
|
halstruct: *W,UNCONO (./ArbitrationSubModule_Testbench.v,93|0): Port 'P_InstMem_In' (which is being used as an output) of entity/module 'ArbitrationSubModule' is being driven inside the design, but not connected (either partially or completely) in its instance 'ArbitrationSubModule_Testbench.uut'.
		assign Bus_DataMem_Read			= 	(D_Bus_GRANT) ? P_DataMem_Read 		: 1'bz;  // When Grant is LOW, show HIGH-Z to the bus
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,182|0): Output port 'Bus_DataMem_Read' is assigned asynchronously.
		assign Bus_DataMem_Write		= 	(D_Bus_GRANT) ? P_DataMem_Write		: 4'bz;	 // 
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,183|0): Output port 'Bus_DataMem_Write' is assigned asynchronously.
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,184|0): Output port 'Bus_DataMem_Address' is assigned asynchronously.
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,185|0): Output port 'Bus_DataMem_Out' is assigned asynchronously.
		assign P_DataMem_In 			= 	(D_Bus_GRANT) ? Bus_DataMem_In		: 32'b0; // When Grant is LOW, show zeros to the processor
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,190|0): Output port 'P_DataMem_In' is assigned asynchronously.
		assign P_DataMem_Ready 			=	(D_Bus_GRANT) ? Bus_DataMem_Ready	: 1'b0;  // When Grant is LOW, Tell the processor memory is not ready
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,189|0): Output port 'P_DataMem_Ready' is assigned asynchronously.
	 	assign D_Bus_RQ = ( P_DataMem_Read | P_DataMem_Write[3] | P_DataMem_Write[2] | P_DataMem_Write[1] | P_DataMem_Write[0]);
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,178|0): Output port 'D_Bus_RQ' is assigned asynchronously.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,162|0): Output port 'Bus_InstMem_Address' is assigned asynchronously.
	  	assign Bus_InstMem_Read		= 	(I_Bus_GRANT) ? P_InstMem_Read			: 1'bz;  // When Grant is LOW, set the bus outputs  to HIGH-Z
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,161|0): Output port 'Bus_InstMem_Read' is assigned asynchronously.
	  	assign P_InstMem_Ready		= 	(I_Bus_GRANT) ? Bus_InstMem_Ready 		: 1'b0;	 // When Grant is LOW, Tell the processor: Instruction is not ready
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,165|0): Output port 'P_InstMem_Ready' is assigned asynchronously.
	  	assign P_InstMem_In 		=	(I_Bus_GRANT) ? Bus_InstMem_In			: 32'b0; // When Grant is LOW, show zeros to the processor						 
|
halstruct: *W,SYNPRT (./ArbitrationSubModule.v,166|0): Output port 'P_InstMem_In' is assigned asynchronously.
	  	assign I_Bus_RQ = P_InstMem_Read ; // When the processor wants an instruction, request the Instruction bus from the Bus Arbiter 
|
halstruct: *W,FDTHRU (./ArbitrationSubModule.v,158|0): Feedthrough detected from input 'P_InstMem_Read' to output 'I_Bus_RQ'.
	  	assign Bus_InstMem_Read		= 	(I_Bus_GRANT) ? P_InstMem_Read			: 1'bz;  // When Grant is LOW, set the bus outputs  to HIGH-Z
|
halstruct: *W,TSBINF (./ArbitrationSubModule.v,161|0): Signal 'Bus_InstMem_Read' defined in module/design-unit 'ArbitrationSubModule', is inferred as a tri-state buffer.
	  	assign Bus_InstMem_Read		= 	(I_Bus_GRANT) ? P_InstMem_Read			: 1'bz;  // When Grant is LOW, set the bus outputs  to HIGH-Z
|
halstruct: *W,SLNOTP (./ArbitrationSubModule.v,161|0): Enable pin of the tristate buffer 'ArbitrationSubModule_Testbench.uut.Bus_InstMem_Read' is not directly controllable by primary input(s).
			Pseudo_I_Memory_Next_State = Pseudo_I_Memory_State_Idle ;
|
halstruct: *W,TSBNTH (./ArbitrationSubModule_Testbench.v,340|0): Logic driven by tri-state buffer 'ArbitrationSubModule_Testbench.uut.Bus_InstMem_Read' is not in a separate module.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halstruct: *W,DALIAS (./ArbitrationSubModule.v,162|0): Aliased constructs found. Wires 'Bus_InstMem_Address' and 'Bus_InstMem_Read' have same drivers.
halstruct: (./ArbitrationSubModule.v,161): Bus_InstMem_Read.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halstruct: *W,TSBINF (./ArbitrationSubModule.v,162|0): Signal 'Bus_InstMem_Address' defined in module/design-unit 'ArbitrationSubModule', is inferred as a tri-state buffer.
	  	assign Bus_InstMem_Address 	= 	(I_Bus_GRANT) ? P_InstMem_Address		: 30'bz; // To avoid contamination of the Bus
|
halstruct: *W,SLNOTP (./ArbitrationSubModule.v,162|0): Enable pin of the tristate buffer 'ArbitrationSubModule_Testbench.uut.Bus_InstMem_Address' is not directly controllable by primary input(s).
		assign Bus_DataMem_Read			= 	(D_Bus_GRANT) ? P_DataMem_Read 		: 1'bz;  // When Grant is LOW, show HIGH-Z to the bus
|
halstruct: *W,TSBINF (./ArbitrationSubModule.v,182|0): Signal 'Bus_DataMem_Read' defined in module/design-unit 'ArbitrationSubModule', is inferred as a tri-state buffer.
		assign Bus_DataMem_Read			= 	(D_Bus_GRANT) ? P_DataMem_Read 		: 1'bz;  // When Grant is LOW, show HIGH-Z to the bus
|
halstruct: *W,SLNOTP (./ArbitrationSubModule.v,182|0): Enable pin of the tristate buffer 'ArbitrationSubModule_Testbench.uut.Bus_DataMem_Read' is not directly controllable by primary input(s).
		assign Bus_DataMem_Write		= 	(D_Bus_GRANT) ? P_DataMem_Write		: 4'bz;	 // 
|
halstruct: *W,DALIAS (./ArbitrationSubModule.v,183|0): Aliased constructs found. Wires 'Bus_DataMem_Write' and 'Bus_DataMem_Read' have same drivers.
halstruct: (./ArbitrationSubModule.v,182): Bus_DataMem_Read.
		assign Bus_DataMem_Write		= 	(D_Bus_GRANT) ? P_DataMem_Write		: 4'bz;	 // 
|
halstruct: *W,TSBINF (./ArbitrationSubModule.v,183|0): Signal 'Bus_DataMem_Write' defined in module/design-unit 'ArbitrationSubModule', is inferred as a tri-state buffer.
		assign Bus_DataMem_Write		= 	(D_Bus_GRANT) ? P_DataMem_Write		: 4'bz;	 // 
|
halstruct: *W,SLNOTP (./ArbitrationSubModule.v,183|0): Enable pin of the tristate buffer 'ArbitrationSubModule_Testbench.uut.Bus_DataMem_Write' is not directly controllable by primary input(s).
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halstruct: *W,DALIAS (./ArbitrationSubModule.v,184|0): Aliased constructs found. Wires 'Bus_DataMem_Address' and 'Bus_DataMem_Read' have same drivers.
halstruct: (./ArbitrationSubModule.v,182): Bus_DataMem_Read.
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halstruct: *W,TSBINF (./ArbitrationSubModule.v,184|0): Signal 'Bus_DataMem_Address' defined in module/design-unit 'ArbitrationSubModule', is inferred as a tri-state buffer.
		assign Bus_DataMem_Address		= 	(D_Bus_GRANT) ? P_DataMem_Address 	: 30'bz; //  When Grant is HIGH, pass on the values	
|
halstruct: *W,SLNOTP (./ArbitrationSubModule.v,184|0): Enable pin of the tristate buffer 'ArbitrationSubModule_Testbench.uut.Bus_DataMem_Address' is not directly controllable by primary input(s).
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halstruct: *W,DALIAS (./ArbitrationSubModule.v,185|0): Aliased constructs found. Wires 'Bus_DataMem_Out' and 'Bus_DataMem_Read' have same drivers.
halstruct: (./ArbitrationSubModule.v,182): Bus_DataMem_Read.
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halstruct: *W,TSBINF (./ArbitrationSubModule.v,185|0): Signal 'Bus_DataMem_Out' defined in module/design-unit 'ArbitrationSubModule', is inferred as a tri-state buffer.
		assign Bus_DataMem_Out			= 	(D_Bus_GRANT) ? P_DataMem_Out 		: 32'bz; // 	that the processsor outputs, to the bus
|
halstruct: *W,SLNOTP (./ArbitrationSubModule.v,185|0): Enable pin of the tristate buffer 'ArbitrationSubModule_Testbench.uut.Bus_DataMem_Out' is not directly controllable by primary input(s).
module ArbitrationSubModule_Testbench;
|
halstruct: *W,SYNASN (./ArbitrationSubModule_Testbench.v,16|0): The module/design-unit 'ArbitrationSubModule_Testbench' contains synchronous as well as asynchronous logic.
halstruct: (./ArbitrationSubModule_Testbench.v,324): One instance/occurence of asynchronous logic at 'ArbitrationSubModule_Testbench.tb_Bus_InstMem_In'.
halstruct: (./ArbitrationSubModule_Testbench.v,294): One instance/occurence of synchronous logic at 'ArbitrationSubModule_Testbench.Pseudo_I_Memory_Current_State'.
module ArbitrationSubModule_Testbench;
|
halstruct: *W,ATLGLC (./ArbitrationSubModule_Testbench.v,16|0): Glue logic inferred in top-level module/design-unit 'ArbitrationSubModule_Testbench'.
halstruct: (./ArbitrationSubModule_Testbench.v,271): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,270): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,340): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,452): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,454): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,219): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,294): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,324): HDL-statement inferred as glue logic.
halstruct: (./ArbitrationSubModule_Testbench.v,327): HDL-statement inferred as glue logic.
			#50 tb_Bus_InstMem_Ready = 1'b1;
|
halstruct: *W,LATINF (./ArbitrationSubModule_Testbench.v,327|0): Process/always block models a latch, or signal 'tb_Bus_InstMem_Ready' is not assigned a value in all branches.
			#50 tb_Bus_InstMem_In = tb_Bus_InstMem_Address + 32'd4;
|
halstruct: *W,LATINF (./ArbitrationSubModule_Testbench.v,324|0): Process/always block models a latch, or signal 'tb_Bus_InstMem_In' is not assigned a value in all branches.
module ArbitrationSubModule_Testbench;
|
halstruct: *N,NUMDFF (./ArbitrationSubModule_Testbench.v,16|0): Number of single-bit D flip-flops present in the hierarchy is 4.
halstruct: Design facts generated in 'hal.design_facts'.
halstruct: Total errors   = 12.
halstruct: Total warnings = 55.

  ==========================================================================

Analysis summary :

 Errors   : (14)
  AWNDEL (2)      CBPAHI (1)      CMBPAU (2)      UNCONI (9)     

 Warnings : (663)
  ACNCPI (1)      ASNRST (2)      ATLGLC (1)      BADSYS (1)     
  BITUNS (4)      CLKINP (1)      CLKNPI (1)      COMBLP (2)     
  CTLCHR (378)    DALIAS (4)      EVTRIG (2)      EXTENZ (4)     
  EXTFSM (1)      FDTHRU (1)      IFXZWC (2)      IGNDLY (13)    
  IMPDTC (4)      IMPTYP (1)      INIUSP (1)      INTTOB (4)     
  LATBAS (1)      LATINF (2)      LATMLG (1)      LCVARN (54)    
  LENCPI (2)      LRGOPR (1)      MAXLEN (53)     MULTMS (1)     
  NBGEND (10)     NEEDIO (1)      NEGCLK (2)      NOBLKN (3)     
  RDBFAS (2)      REVROP (3)      RSTINP (1)      SEPLIN (2)     
  SLNOTP (6)      STYVAL (26)     SYNASN (1)      SYNPRT (11)    
  SYNTXZ (4)      TRNMBT (1)      TRUNCZ (6)      TSBINF (6)     
  TSBNTH (1)      TSMHOL (1)      UASREG (7)      UCCONN (6)     
  UELOPR (1)      UNCONO (9)      URDWIR (9)      USEPAR (1)     

 Notes    : (20)
  CDNOTE (1)      CLKINF (3)      FFASRT (2)      FSMIDN (2)     
  IDLENG (9)      INFNOT (1)      NUMDFF (1)      PRTCNT (1)     

Analysis complete.

 ==========================================================================

To analyze results, run following command :
    ncbrowse -64bit -cdslib /localdisk/users/papadako/diplomatiki/A_HDL/Arbitration_submodule/1_SIMVISION/cds.lib -sortby severity -sortby category -sortby tag hal.log

